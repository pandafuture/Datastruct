# 串

- **字符串（串）** 是由 0 个或多个字符组成的有限序列。

- 串的数据对象限定为 **字符集**

- **串名**

- **串的值** ：单引号（双引号）括起来的字符序列内容

- **串的长度** ：串中字符的个数 n 。n 为 0 时串为 **空串**（用 $\emptyset$ 表示）

- **子串** ：串中 **任意多个** **连续** 的字符组成的子序列。（空串也是子串）

- **主串** ：包含子串的串

- **字符在串中的位置** ：某个字符在串中的序号（从 1 开始）

- **子串在主串中的位置** ：子串的第一个字符在主串中的位置

- **两个串相等** ：两个串的长度相等，且每个对应位置的字符都相等

- **空格串** ：一个或多个空格组成的串。（空格串不是空串）

- 串的 **基本操作** （以子串作为操作对象）
  - **赋值操作**
  - **复制操作**
  - **判空操作**
  - **比较操作**
  - **求串长**
  - **求子串**
  - **串联接**
  - **定位操作**
  - **清空操作**
  - **销毁串**

- 串的 **存储结构** 可用 **定长顺序存储表示（静态顺序串）** 、**堆分配存储表示（动态顺序串）** 、**块链存储表示（链串）**

- **块链存储表示** 的串中，每个结点称为 **块** ，整个链表称为 **块链结构**





# 串的顺序存储的实现
## 定长顺序存储（使用静态数组）
1. 先 **预定义串的最大长度**
    ```
    #define MAX_SIZE 255  // 预定义最大串长为 255
    ```

2. 定义串的 **存储结构** 。
   1. 使用 **静态数组** 存储串字符。每个分量都存储一个字符，除了 **char[0] 不使用**
   2. 设置一个整型变量，用来记录串的 **实际长度**
    ```
    // 串的顺序存储结构（使用静态数组实现）
    struct SqString {
        char ch[MAX_SIZE];  // 存储串字符的数组，每个分量存储一个字符（ch[0] 不使用）
        int length;  // 串的实际长度（从 1 开始存储）
    };
    ```

3. **初始化串**
   1. 传入 **串名 &S**
   2. 只需把 **串长设为 0** ，表示空串。
    ```
    // 初始化串（创建空串）
    void InitString(SqString &S) {
        S.length = 0;  // 长度设为 0，表示空串
    }
    ```

4. **赋值操作** ：把 **chars** 赋值给 **串S**
   1. 传入 **串名S** 、 **字符串 const char *chars** （表示不可改变指针指向的字符内容）
   2. 计算输入字符数组的 **长度**
   3. 先检查输入长度 **是否超过最大容量**（实际可用最大容量为 **MAX_SIZE - 1**）
   4. 从 char[1] 开始存放赋值内容
   5. 更新串长度
    ```
    bool StrAssign(SqString &S, const char *chars) {
        int len = strlen(chars);  // 计算输入字符数组的长度
        // 检查输入长度是否超过最大容量（实际可用长度为 MAX_SIZE-1）
        if(len > MAX_SIZE - 1) {
            std::cerr << "错误：超过最大串长度" << std::endl;
            return false;
        }

        // 开始赋值（从 char[1] 开始存放）
        for(int i = 0; i < len; i++) {
            S.ch[i + 1] = chars[i];  // 第几个位序的字符就放在数组中的第几个下标位置
        }
        S.length = len;  // 更新串长度
        return true;
    }
    ```

5. **复制操作** ：把 **串T** **复制给** **串S**
   1. 先传入 **串S的串名 &S** 、**串T的串名 T**
   2. 检查 串T **是否为空**
   3. 如果串T为空，就只需把串S初始化为空串即可
   4. 如果串T不为空，就从 char[1] 开始逐字符复制内容到串S
   5. 更新串长
    ```
    // 复制操作（把串 T 复制给串 S）
    bool StrCopy(SqString &S, const SqString T) {
        // 检查源串是否为空
        if(T.length == 0) {
            // 如果为空，就只要把目标串初始化为空就行
            InitString(S);
            return true;
        }

        // 开始复制内容（从 char[1] 开始）
        for(int i = 1; i <= T.length; i++) {
            S.ch[i] = T.ch[i];  // 逐字符复制
        }
        S.length = T.length;  // 更新串长度
        return true;
    }
    ```

6. **判空**
   1. 直接返回串的长度是否为 0
    ```
    // 判空操作
    bool StrEmpty(SqString S) {
        return S.length == 0;  // 长度为 0 即为空串
    }
    ```

7. **比较操作** ：若 S > T，则返回值 > 0；若S = T，则返回值 = 0；若 S < T，则返回值 < 0
   1. 传入要比较的 **串名 S，T**
   2. 从下标 1 开始，逐字符比较
   3. 返回第一个不同字符的差值
   4. 如果所有字符都相同，就比较长度
    ```
    // 比较操作（若 S > T，则返回值大于 0；若 S = T，则返回值等于 0；若 S < T，则返回值小于 0）
    int StrCompare(SqString S, SqString T) {
        // 逐字符比较（从下标 1 开始）
        for(int i = 1; i <= (S.length < T.length ? S.length : T.length); i++) {
            if(S.ch[i] != T.ch[i])
                return S.ch[i] - T.ch[i];  // 返回第一个不同字符的差值
        }
        return S.length - T.length;  // 所有字符都相同，则比较长度
    }
    ```

8. **求串长**
   1. 直接返回长度
    ```
    // 求串长
    int StrLength(SqString S) {
        return S.length;  // 直接返回长度
    }
    ```

9. **求子串** ：用 Sub 返回 串S 的第 pos 个字符起长度为 len 的字符
   1. 传入 **子串名 &Sub** 、**主串名 S** 、**起始位置 pos** 、**子串长度 len**
   2. 首先检查起始位置和子串长度是否越界
   3. 然后再截取子串内容
   4. 最后更新子串长度
    ```
    // 求子串（用 Sub 返回 串S 的第 pos 个字符起长度为 len 的子串）
    bool SubString(SqString &Sub, SqString S, int pos, int len) {
        // 检查位置和子串长度是否越界
        if(pos < 1 || pos > S.length || len < 0 || pos + len - 1 > S.length) {
            std::cerr << "错误：非法位置或长度" << std::endl;
            return false;
        }

        // 截取子串内容
        for(int i = 1; i <= len; i++) {
            Sub.ch[i] = S.ch[pos + i - 1];
        }
        Sub.length = len;
        return true;
    }
    ```

10. **串联接** ：把串S1和串S2联接成新串T
    1. 传入 **新串名 &T** 、**要连接的串名 S1，S2**
    2. 检查两个串的总长度是否超过定义的最大长度。（实际最大使用长度为 MAX_SIZE - 1）
    3. 复制第一个串的内容
    4. 复制第二个串的内容，接在第一个串后面
    5. 更新串T的串长
    ```
    // 串联接（将 串S1 和 串S2 联接成新串T）
    bool Concat(SqString &T, SqString S1, SqString S2) {
        // 检查总长度是否超过最大长度
        if(S1.length + S2.length >  MAX_SIZE - 1) {
            std::cerr << "错误：联接后串超过最大长度" << std::endl;
            return false;
        }

        // 复制第一个串的内容
        for(int i = 1; i <= S1.length; i++) {
            T.ch[i] = S1.ch[i];
        }

        // 复制第二个串的内容（接在第一个串后面）
        for(int i = 1; i <= S2.length; i++) {
            T.ch[S1.length + i] = S2.ch[i];
        }

        T.length = S1.length + S2.length;  // 更新串长度
        return true;
    }
    ```

11. **定位操作** ：若主串S中存在与串T值相同的子串，则返回它再主串S中第一次出现的位置；否则返回 0
    1. 首先传入 **主串名 S** 、**要定位的子串名 T**
    2. 先判断子串如果是空串，就直接返回 0
    3. 如果不是空串就获取两个串的长度
    4. 然后从主串的第一个字符开始获取长度为子串长度的子串，并暂存再 sub 中
    5. 把 sub 中暂存的子串和目标子串进行比较操作，如果不同，则继续，如果相同，则返回子串再主串中的位置
    6. 如果没找到就返回 0
    ```
    // 定位操作（若 主串S 中存在与 串T 值相同的子串，则返回它在主串S中第一次出现的位置；否则返回 0）
    int Index(SqString S, SqString T) {
        // 空串是任意串的子串
        if(T.length == 0)
            return 0;

        int n = StrLength(S);  // 获取 串S 的长度
        int m = StrLength(T);  // 获取 串T 的长度
            
        int i = 1;
        SqString sub;  // 用于暂存子串
        // 从 串S 的第一个字符开始获取长度为 m 的子串，并暂存在 串sub 中
        while(i <= n - m + 1) {
            SubString(sub, S, i, m);  // 获取子串
            if(StrCompare(sub, T) != 0)  // 进行比较
                ++i;
            else return i;  // 返回子串在主串中的位置
        }
        return 0;  // 如果没找到就返回 0
    }
    ```

12. **清空操作**
    1.  传入 **要清空的串名 &S**
    2.  把长度设置为 0，即为空串
    ```
    // 清空操作
    void ClearString(SqString &S) {
        S.length = 0;  // 长度重置为 0，即为空串
    }
    ```

13. **销毁串**
    1.  传入 **要销毁的串名 &S**
    2.  静态数组无需是否内存，只需要清空就行
    ```
    // 销毁串
    void DestroyString(SqString &S) {
        // 静态数组无需释放内存，等同于清空
        ClearString(S);
    }
    ```

14. **打印串的内容**
    1.  传入 **要打印的串名 S**
    2.  先判断串是否为空
    3.  从 char[1] 开始打印串内容
    ```
    // 打印串内容
    void PrintString(SqString S) {
        // 先判断串是否为空
        if(StrEmpty(S)) {
            std::cout << "串为空" << std::endl;
            return;
        }

        // 打印串内容（从下标1开始打印）
        for(int i = 1; i <= S.length; i++) {
            std::cout << S.ch[i];
        }
        std::cout << std::endl;
    }
    ```




## 堆分配存储（使用动态分配）
1. 串的 **堆分配存储结构**（动态分配实现）。包括指向串的基地址的 **指针** 、**串的长度** 、**当前分配的存储区长度**
    ```
    // 串的堆分配存储结构（动态分配实现）
    struct HString {
        char *ch;  // 按串长分配存储区，ch 指向串的基地址
        int length;  // 串的长度
        int capacity;  // 当前分配的存储区长度
    };
    ```

2. **初始化串**
   1. 传入 **串名 &S**
   2. 设置 **初始容量**
   3. 分配内存空间
   4. 如果分配失败就退出程序
   5. 最后把串长初始化为 0
    ```
    // 初始化串（创建空串）
    void InitString(HString &S) {
        S.capacity = 10;  // 初始容量设为 10
        // 分配 capacity + 1（因为 char[0] 不使用）个大小为 char 的内存空间，并用 char 类型的指针返回地址
        S.ch = (char*)malloc((S.capacity + 1) * sizeof(char));

        // 如果内存分配失败，则退出程序
        if(!S.ch) {
            std::cerr << "内存分配失败" << std::endl;
            exit(1);
        }

        // 初始长度设为 0
        S.length = 0;
    }
    ```

3. **赋值操作** ：把 **chars** 赋值给 **串S**
   1. 传入 **串名 *S** 、**赋值内容 const char \*chars**（const 表示 chars 内容不可修改）
   2. 计算输入字符串的长度
   3. 检查是否需要扩容
   4. 从 ch[1] 开始赋值给 串S
   5. 更新串的长度
    ```
    // 赋值操作（把 chars 赋值给 串S）
    bool StrAssign(HString &S, const char *chars) {
        // 计算输入字符数组的长度
        int len = strlen(chars);

        // 检查是否需要扩容
        if(len > S.capacity) {
            // 用 realloc 重新分配已申请的内存块大小（传入原指针，总字节数）
            char* new_ch = (char*)realloc(S.ch,(len + 1) * sizeof(char));
            // 如果重新分配失败，则退出
            if(!new_ch) {
                std::cerr << "内存分配失败" << std::endl;
                return false;
            }
            S.ch = new_ch;  // 更新基地址
            S.capacity = len;  // 更新容量
        }

        // 从 ch[1] 开始存储字符
        for(int i = 0; i < len; i++) {
            S.ch[i + 1] = chars[i];
        }
        S.length = len;  // 更新串的长度
        return true;
    }
    ```

4. **复制操作** ：把 串T 复制给 串S
   1. 传入 **串名 &S** 、**串名 &T**（& 是为了避免整个串结构体被复制，使用 & 就可只传递引用（即指针），提高效率）
   2. 检查 串T 是否为空串
   3. 检查是否需要扩容
   4. 从 char[1] 开始复制给 串S
   5. 更新串长
    ```
    // 复制操作（把串T复制给串S）
    bool StrCopy(HString &S, const HString &T) {
        // 检查源串是否为空
        if(T.length == 0) {
            S.length = 0;  // 目标串也设为空串
            return true;
        }

        // 检查是否需要扩容
        if(T.length > S.capacity) {
            char* new_ch = (char*)realloc(S.ch,(T.length + 1) * sizeof(char));
            if(!new_ch) {
                std::cerr << "内存分配失败" << std::endl;
                return false;
            }
            S.ch = new_ch;  // 更新存储区指针
            S.capacity = T.length;  // 更新存储区容量
        }

        // 从 char[1] 开始复制内容
        for(int i = 1; i <= T.length; i++) {
            S.ch[i] = T.ch[i];
        }
        S.length = T.length;  // 更新串长度
        return true;
    }
    ```

5. **判空**
   1. 传入 **串名 &S**
   2. 直接返回串长是否为 0
    ```
    // 判空操作
    bool StrEmpty(const HString &S) {
        return S.length == 0;
    }
    ```

6. **比较操作**
   1. 传入要比较的串名 **&S** 和 **&T**
   2. 逐字符比较，然后返回第一个不同字符的差值
   3. 如果所有字符都相同则比较长度
    ```
    // 比较操作
    int StrCompare(const HString &S, const HString &T) {
        // 逐字符比较（从数组下标 1 开始）
        for(int i = 1; i <= (S.length < T.length ? S.length : T.length); i++) {
            if(S.ch[i] != T.ch[i])
                return S.ch[i] - T.ch[i];  // 返回第一个不同字符的差值
        }
        return S.length - T.length;  // 所有字符都相同则比较长度
    }
    ```

7. **求串长**
   1. 传入 **串名 &S**
   2. 直接返回串长
    ```
    // 求串长
    int StrLength(const HString &S) {
        return S.length;
    }
    ```

8. **求子串** ：用 Sub 返回 串S 的第 pos 个字符起长度为 len 的子串
   1. 检查位置和长度合法性
   2. 检查 Sub 的容量
   3. 开始获取子串
   4. 更新串长
    ```
    // 求子串（用 Sub 返回 串S 的第 pos 个字符起长度为 len 的子串）
    bool SubString(HString &Sub, const HString &S, int pos, int len) {
        // 检查位置和长度合法性
        if(pos < 1 || pos > S.length || len < 0 || pos + len - 1 > S.length) {
            std::cerr << "错误：非法位置或长度" << std::endl;
            return false;
        }

        // 确保 Sub 有足够容量
        if(len > Sub.capacity) {
            char* new_ch = (char*)realloc(Sub.ch, (len + 1) * sizeof(char));
            if(!new_ch) {
                std::cerr << "内存分配失败" << std::endl;
                return false;
            }
            Sub.ch = new_ch;
            Sub.capacity = len;
        }

        // 复制子串内容
        for(int i = 1; i <= len; i++) {
            Sub.ch[i] = S.ch[pos + i - 1];
        }
        Sub.length = len;  // 更新串长
        return true;
    }
    ```

9. **串联接** ：将 串S1 和 串S2 联接成 新串T
   1.  传入 **新串名 &T** 、要联接的两个串的串名 **&S1 &S2**
   2.  计算两个串的总长度
   3.  检查 新串T 是否需要扩容
   4.  复制 S1 的内容
   5.  复制 S2 的内容
   6.  更新串长
    ```
    // 串联接（将 串S1 和 串S2 联接成新串T）
    bool Concat(HString &T, const HString &S1, const HString &S2) {
        // 计算总长度
        int totalLen = S1.length + S2.length;

        // 检查是否要扩容
        if(totalLen > T.capacity) {
            char* new_ch = (char*)realloc(T.ch, (totalLen + 1) * sizeof(char));
            if(!new_ch) {
                std::cerr << "内存分配失败" << std::endl;
                return false;
            }
            T.ch = new_ch;
            T.capacity = totalLen;
        }

        // 复制 S1 的内容
        for(int i = 1; i <= S1.length; i++) {
            T.ch[i] = S1.ch[i];
        }

        // 复制 S2 的内容
        for(int i = 1; i <= S2.length; i++) {
            T.ch[S1.length + i] = S2.ch[i];
        }

        T.length = totalLen;  // 更新串长度
        return true;
    }
    ```

10. **定位操作** ：返回 子串T 在 主串S 中第一次出现的位置
    1.  传入 **主串名 &S** 、**子串名 &T**
    2.  判断 子串T 是不是空串，如果是空串就返回 0
    3.  获取主串和目标子串的长度
    4.  声明并初始化一个串，用来暂存子串
    5.  从主串第一个位置开始获取子串，并对比
    6.  如果成功匹配就返回子串在主串中的位置
    7.  如果匹配失败就返回 0
    ```
    // 定位操作（返回 子串T 在 主串S 中第一次出现的位置）
    int Index(const HString &S, const HString &T) {
        // 空串是任意串的子串
        if(T.length == 0)
            return 0;

        int n = StrLength(S);  // 获取主串的长度
        int m = StrLength(T);  // 获取目标子串的长度
        int i = 1;
        HString sub;  // 用于暂存子串
        InitString(sub);  // 初始化
        while(i <= n - m + 1) {
            SubString(sub, S, i, m);  // 获取子串
            if(StrCompare(sub, T) != 0)  // 进行比较
                ++i;
            else
                return i;  // 如果匹配成功就返回子串在主串中的位置
        }
        return 0;
    }
    ```

11. **清空操作**
    1.  传入 **串名&S**
    2.  把串长重置为 0
    ```
    // 清空操作
    void ClearString(HString &S) {
        S.length = 0;  // 长度重置为 0
    }
    ```

12. **销毁操作**
    1.  传入 **串名 &S**
    2.  释放动态分配的内存空间
    3.  把指向存储空间的指针置为空
    4.  串长归零
    5.  把串的容量归零
    ```
    // 销毁串
    void DestroyString(HString &S) {
        free(S.ch);  // 释放动态分配的内存
        S.ch = nullptr;  // 指针置空
        S.length = 0;  // 长度归零
        S.capacity = 0;  // 容量归零
    }
    ```
13. **打印串内容**
    1.  传入 **串名 &S**
    3.  从 char[1] 开始打印
    ```
    // 打印串内容
    void PrintString(const HString &S) {
        // 先判断串是否为空
        if(StrEmpty(S)) {
            std::cout << "串为空" << std::endl;
            return;
        }

        // 开始打印
        for(int i = 1; i <= S.length; i++) {
            std::cout << S.ch[i];
        }
        std::cout << std::endl;
    }
    ```




# 串的块链存储的实现（使用链表）
1. 先定义 **块的大小**
    ```
    #define BLOCK_SIZE 4  // 定义块的大小（每个结点存储的字符数）
    ```

2. 定义 **块的结构**
   1. 存储字符的数组
   2. 指向下一个块的指针
    ```
    // 块链结点结构
    struct Block {
        char ch[BLOCK_SIZE];  // 存储字符的数组
        Block *next;  // 指向下一个块的指针
    };
    ```

3. 串的 **块链存储结构**
   1. 头指针
   2. 尾指针
   3. 串长
    ```
    // 串的块链存储结构
    struct LString {
        Block *head;  // 指向第一个块的指针
        Block *tail;  // 指向最后一个块的指针
        int length;  // 串的实际长度（字符个数）
    };
    ```

4. **初始化串**
   1. 传入 **串名 &S**
   2. 将头指针和尾指针置为空
   3. 串长设为 0
    ```
    // 初始化串
    void InitString(LString &S) {
        S.head = nullptr;  // 头指针置空
        S.tail = nullptr;  // 尾指针置空
        S.length = 0;  // 长度设为 0
    }
    ```

5. **赋值操作**
   1. 传入 **串名 &S** 、**字符数组 chars**
   2. 先清空块链中原有的内容
   3. 再重置链表状态
      1. 重置头指针
      2. 重置尾指针
      3. 重置串长
   4. 判断 chars 是否为空，如果为空，则赋值操作已完成，可直接返回
   5. 如果 chars 不为空，则计算所需的块数
   6. 然后逐一处理每个块
      1. 新建一个块
      2. 计算这个块中应存储的字符数量
         1. 先判断这个块是不是最后一块
         2. 如果不是最后一块，就说明这个块要存满
         3. 如果是最后一块，那就要判断这个最后一块是否会被填满，要填多少字符
      3. 把字符赋值到当前块
      4. 最后一个块占不满时，用特殊字符填充
      5. 把新块的 next 指向空
      6. 把新块链接到链表尾部
         1. 如果是链表中第一个块，那就把头指针和尾指针都指向新块
         2. 如果不是第一个块，就只需把最后一块的 next 指向新块，然后修改尾指针即可
      7. 最后更新串长
    ```
    // 赋值操作（把 chars 赋值给 串S）
    bool StrAssign(LString &S, const char* chars) {
        // 先清空块链中所有内容
        Block *p = S.head;  // 新建一个指针，指向第一个块
        while(p) {
            Block *temp = p;  // 再新建一个指针，指向 指针p 指向的块
            p = p -> next;
            delete temp;  // 删除 temp 指向的块
        }

        // 重置链表状态
        S.head = nullptr;  // 重置头指针
        S.tail = nullptr;  // 重置尾指针
        S.length = 0;  // 重置串长

        // 如果是空串，现在就已完成操作，可直接返回
        int len = strlen(chars);  // 计算输入字符数组的长度
        if(len == 0) {
            return true;
        }

        // 计算需要的块数
        int blockCount = (len + BLOCK_SIZE - 1) / BLOCK_SIZE;

        // 处理每个块
        for(int i = 0; i < blockCount; i++) {
            Block* newBlock = new Block();  // 创建新块

            // 计算当前块应存储的字符数
            // 先判断当前块是否是最后一块
            // 如果不是，就说明当前块要存满
            // 如果是，那就再判断，当前块会不会被填满
            // 如果会被填满，就填满
            // 如果不会被填满，就计算需要填多少字符
            int charsInBlock = (i == blockCount - 1) ? (len % BLOCK_SIZE == 0 ? BLOCK_SIZE : len % BLOCK_SIZE) : BLOCK_SIZE;

            // 复制字符到当前块
            for(int j = 0; j < charsInBlock; j++) {
                newBlock -> ch[j] = chars[i * BLOCK_SIZE + j];
            }

            // 最后一个块占不满时，用特殊字符填充
            for(int j = charsInBlock; j < BLOCK_SIZE; j++) {
                newBlock -> ch[j] = '#';  // 填充字符
            }

            newBlock -> next = nullptr;  // 把新块的 next 指向空

            // 链接到链表
            if(!S.head) {
                S.head = newBlock;  // 如果当前链表中没有结点，就把新块作为第一个结点
                S.tail = newBlock;  // 更新尾指针
            }
            else {
                S.tail -> next = newBlock;  // 链接到链表尾部
                S.tail = newBlock;  // 更新尾指针
            }

            S.length += charsInBlock;  // 串的长度增加新增的字符数量
        }
        return true;
    }
    ```

6. **复制操作**
   1. 传入 **容器串名 &S** 、**源串名 &T**
   2. 先清空 串S 原有的内容
   3. 重置链表状态
   4. 如果串T是空串，此时就已完成复制，可直接返回
   5. 遍历串T的所有块
      1. 新建一个指针 tCurrent 用于遍历串T
      2. 新建一个块，用来复制当前的T的块
      3. 计算当前块需要实际存储的字符数量
      4. 执行复制
      5. 把新块的 next 指向空
      6. 将新块链接到串S中
      7. 移动 tCurrent 指针到串T 的下一个块
   6. 更新串长
    ```
    // 复制操作（把 串T 复制给 串S）
    bool StrCopy(LString &S, const LString &T) {
        // 先清空串S原有内容
        Block *p = S.head;  // 新建一个指针 p ，指向第一个结点
        while(p) {
            Block *temp = p;  // 新建一个指针 temp ，指向 p 指向的结点
            p = p -> next;
            delete temp;  // 删除 temp 指向的块
        }

        // 重置链表状态
        S.head = nullptr;  // 重置头指针为空
        S.tail = nullptr;  // 重置尾指针为空
        S.length = 0;  // 重置串长

        // 如果 串T 是空串，就可直接返回了
        if(T.length == 0) {
            return true;
        }

        Block *tCurrent = T.head;  // 用于遍历 串T 的指针

        // 遍历 串T 的所有块
        while(tCurrent) {
            Block *newBlock = new Block();  // 创建新块

            // 计算当前块需要实际存储的字符数
            int charsInBlock = (tCurrent == T.tail) ? (T.length % BLOCK_SIZE == 0 ? BLOCK_SIZE : BLOCK_SIZE) : BLOCK_SIZE;
            
            // 复制字符
            for(int i = 0; i < BLOCK_SIZE; i++) {
                newBlock -> ch[i] = tCurrent -> ch[i];
            }

            newBlock -> next = nullptr;  // 新块的 next 置为空

            // 将新块添加到 串S 的尾部
            if(!S.head) {
                S.head = newBlock;
                S.tail = newBlock;
            }
            else {
                S.tail -> next = newBlock;
                S.tail = newBlock;
            }

            // 移动到 串T 的下一个块
            tCurrent = tCurrent -> next;
        }
        S.length = T.length;  // 更新串长度
        return true;
    }
    ```

7. **判空操作**
   1. 传入 **串名 &S**
   2. 直接返回串长是否为空即可
    ```
    // 判空操作
    bool StrEmpty(const LString &S) {
        return S.length == 0;  // 串长为 0 即为空串
    }
    ```

8. **比较操作**
   1. 传入 **要比较两个串名 &S &T**
   2. 新建一个指针 *sBlock 指向 串S 的第一个块
   3. 新建一个指针 *tBlock 指向 串T 的第一个块
   4. 设置一个 串S 的当前块的块内索引
   5. 设置一个 串T 的当前块的块内索引
   6. 设置一个计数器，记录当前已比较了几个字符
   7. 进行逐字符比较
      1. 遍历 串S 和 串T 直到计数器超过其中一个串的串长
      2. 比较当前字符
      3. 比较完当前字符后，更新索引和计数
      4. 读到串S的块内边界时，就移动到串S的下一个块，并重置块内字符索引
      5. 读到串T的块边界时，就移动到串T的下一个块，并重置块内字符索引
   8. 如果字符都相同，就比较长度
        ```
    // 比较操作
    int StrCompare(const LString &S, const LString &T) {
        Block *sBlock = S.head;  // 新建一个指针用来标记S的当前块，初始指向第一个块
        Block *tBlock = T.head;  // 新建一个指针用来标记T的当前块，初始指向第一个块
        int sIndex = 0;  // S当前块内的字符索引
        int tIndex = 0;  // T当前块内的字符索引
        int count = 0;  // 已比较的字符计数

        // 比较
        while(count < S.length && count < T.length) {
            // 比较当前字符
            if(sBlock -> ch[sIndex] != tBlock -> ch[tIndex]) {
                return sBlock -> ch[sIndex] - tBlock -> ch[tIndex];
            }

            // 更新索引和计数
            sIndex++;
            tIndex++;
            count++;

            // 处理 串S 的块边界
            if(sIndex == BLOCK_SIZE) {
                sBlock = sBlock -> next;  // 移动到下一个块
                sIndex = 0;  // 重置块内字符索引
            }

            // 处理 串T 的块边界
            if(tIndex == BLOCK_SIZE) {
                tBlock = tBlock -> next;  // 移动到下一个块
                tIndex = 0;  // 重置块内索引
            }
        }
        // 如果字符都相同，就比较长度
        return S.length - T.length;
    }
    ```

9. **求串长**
   1.  传入 **串名 &S**
   2.  直接返回串长
    ```
    // 求串长
    int StrLength(const LString &S) {
        return S.length;  // 直接返回长度
    }
    ```

10. **求子串**
    1.  传入 **子串名 &Sub** 、**主串 S** 、**起始位置 pos** 、**子串长 len**
    2.  首先检查 **输入是否合法** 。起始位置不能小于 1 ，也不能超过主串长。子串长度不能小于 0 ，也不能从起始位置处超过主串长
    3.  清空 Sub 中原有内容
    4.  重置链表状态
    5.  判断如果子串长为空，则直接返回
    6.  求子串
        1.  先根据起始位置计算在主串中的起始块和块内偏移
        2.  定位到起始块
        3.  复制子串
    7. 更新祖传长度
    ```
    // 求子串（用 Sub 返回从 主串S 的第 pos 个字符开始取长度为 len 的子串）
    bool SubString(LString &Sub, const LString &S, int pos, int len) {
        // 检查输入是否合法
        if(pos < 1 || pos > S.length || len < 0 || pos + len - 1 > S.length) {
            std::cerr << "错误：非法位置或长度" << std::endl;
            return false;
        }

        // 清空 Sub 中原有内容
        Block *p = Sub.head;  // 新建一个指针，指向 Sub 的头指针指向位置
        while(p) {
            Block *temp = p;  // 新建一个指针，指向 p 指向的位置
            p = p -> next;
            delete temp;  // 释放当前块
        }

        // 重置链表状态
        Sub.head = nullptr;
        Sub.tail = nullptr;
        Sub.length = 0;

        // 如果 len 是空串，则直接返回
        if(len == 0) {
            return true;
        }

        // 求子串
        // 计算起始块和块内偏移
        int startBlock = (pos - 1) / BLOCK_SIZE;
        int startOffset = (pos - 1) % BLOCK_SIZE;

        // 定位到起始块
        Block *currentBlock = S.head;  // 新建一个指针，初始指向 串S 头指针指向的位置
        for(int i = 0; i < startBlock; i++) {
            // 从 串S 的第一个块开始遍历，直到找到起始块
            currentBlock = currentBlock -> next;
        }

        int count = 0;  // 已复制的字符数

        // 复制子串
        while(count < len) {
            // 创建新块
            Block *newBlock = new Block();  // 创建新块

            // 初始化新块
            for(int i = 0; i < BLOCK_SIZE; i++) {
                newBlock -> ch[i] = '#';  // 默认填充
            }

            newBlock -> next = nullptr;  // 新块的 next 指向空

            // 将新块添加到 串Sub 的尾部
            if(!Sub.head) {
                // 如果是空串，那么头指针和尾指针都指向新块
                Sub.head = newBlock;
                Sub.tail = newBlock;
            }
            else {
                // 先链接到串尾
                Sub.tail -> next = newBlock;
                // 再修改串尾指针
                Sub.tail = newBlock;
            }

            // 复制字符到新块
            int charIndex = 0;  // 新块内的字符索引
            while(charIndex < BLOCK_SIZE && count < len) {
                // 复制字符
                newBlock -> ch[charIndex] = currentBlock -> ch[startOffset];

                // 移动索引
                charIndex++;
                count++;
                startOffset++;

                // 检查是否需要移动到下一个块
                if(startOffset == BLOCK_SIZE && currentBlock -> next) {
                    currentBlock = currentBlock -> next;  // 移动到下一个块
                    startOffset = 0;  // 重置块内索引
                }
            }
        }

        // 更新子串长度
        Sub.length = len;
        return true;
    }
    ```

11. **串联接**
    1.  传入 **新串名 &T** 、**第一个串名 S1** 、**第二个串名 S2**
    2.  清空 串T 原有内容
    3.  重置链表状态
    4.  如果 S1 和 S2 是空串，此时就可直接返回
    5.  复制 S1 到 串T
        1.  新建一个指针 s1Block ，指向 S1 的第一个块
        2.  遍历 串S1 的每一个块
        3.  创建新块
        4.  计算当前块实际存储的字符数
        5.  如果当前块是最后一块，则要计算，最后一块中有多少有效字符
        6.  如果不是最后一块，则块内要填满有效字符
        7.  复制有效字符
        8.  最后一块的空余部分用 # 填充
        9.  把新块添加到 串T 中
        10. 移动指针到 串S1 的下一个块
        11. 更新 串T 的串长
    6. 复制 S2 到 串T
       1. 新建一个指针 s2Block ，指向 S2 的第一个块
       2. 遍历 串S2 的每一个块
       3. 创建新块
       4. 计算当前块实际存储的字符数
       5. 如果当前块是最后一块，则要计算最后一块中有多少有效字符
       6. 如果不是最后一块，则块内要填满有效字符
       7. 复制有效字符
       8. 填充剩余部分
       9. 把新块的 next 指向空
       10. 把新块添加到 串T 中
       11. 把指针移到 串S2 的下一个块
       12. 更新 串T 的长度
    ```
    // 串联接（将 串S1 和 串S2 联接成 新串T）
    bool Concat(LString &T, const LString &S1, const LString &S2) {
        // 清空 串T 原有内容
        Block *p = T.head;  // 新建一个指针，指向 串T 的头指针指向的结点
        while(p) {
            Block *temp = p;
            p = p -> next;
            delete temp;
        }

        // 重置链表状态
        T.head = nullptr;
        T.tail = nullptr;
        T.length = 0;

        // 处理 S1、S2 是空串的情况
        if(S1.length == 0 && S2.length == 0) {
            return true;
        }

        // 复制 S1 到 T
        if(S1.length > 0) {
            Block *s1Block = S1.head;  // 新建一个指针，指向 串S1 的第一个结点

            while(s1Block) {
                // 创建新块
                Block *newBlock = new Block();

                // 计算当前块实际存储的字符数
                int charsInBlock;
                if(s1Block == S1.tail) {
                    // 如果当前块是 S1 的最后一个块
                    // 计算最后一块中的字符数
                    int remainder = S1.length % BLOCK_SIZE;
                    charsInBlock = (remainder == 0) ? BLOCK_SIZE : remainder;
                }
                else {
                    // 如果当前不是最后一块，那么块中的字符数是满的
                    charsInBlock = BLOCK_SIZE;
                }

                // 只复制有效字符
                for(int i = 0; i < charsInBlock; i++) {
                    newBlock -> ch[i] = s1Block -> ch[i];
                }

                // 填充剩余部分
                for(int i = charsInBlock; i < BLOCK_SIZE; i++) {
                    newBlock -> ch[i] = '#';
                }

                newBlock -> next = nullptr;  // 新块的 next 置为空

                // 将新块添加到 T 的尾部
                if(!T.head) {
                    T.head = newBlock;
                    T.tail = newBlock;
                }
                else {
                    T.tail -> next = newBlock;
                    T.tail = newBlock;
                }

                // 移动到 S1 的下一个块
                s1Block = s1Block -> next;
            }
            T.length = S1.length;
        }

        // 复制 S2 到 T 的尾部
        if(S2.length > 0) {
            Block *s2Block = S2.head;  // 新建一个指针，指向 S2 的头指针指向的结点
            while(s2Block) {
                // 创建新块
                Block *newBlock = new Block();  // 创建新块

                // 计算当前块实际存储的字符数
                int charsInBlock;
                if(s2Block == S2.tail) {
                    // 如果当前块是最后一块
                    // 计算最后一块中有多少字符
                    int remainder = S2.length % BLOCK_SIZE;
                    charsInBlock = (remainder == 0) ? BLOCK_SIZE : remainder;
                }
                else {
                    // 如果当前块不是最后一块，就存满
                    charsInBlock = BLOCK_SIZE;
                }

                // 只复制有效字符
                for(int i = 0; i < charsInBlock; i++) {
                    newBlock -> ch[i] = s2Block -> ch[i];
                }

                // 填充剩余部分
                for(int i = charsInBlock; i < BLOCK_SIZE; i++) {
                    newBlock -> ch[i] = '#';
                }

                // 把新块的 next 指向空
                newBlock -> next = nullptr;

                // 将新块添加到 T 的尾部
                if(!T.head) {
                    // 修改头指针和尾指针
                    T.head = newBlock;
                    T.tail = newBlock;
                }
                else {
                    // 添加到 T 的尾部
                    T.tail -> next = newBlock;
                    // 修改尾指针
                    T.tail = newBlock;
                }

                // 移动到S2的下一块
                s2Block = s2Block -> next;
            }
            // 更新串长
            T.length += S2.length;
        }
        return true;
    }
    ```

12. **定位操作**
    1.  传入 **主串名 S** 、**子串名 T**
    2.  先判断 子串T 是否为空串，空串是任意串的子串，可直接返回 1
    3.  对输入判断是否合法。主串不能比子串短
    4.  遍历主串中的所有起始位置
        1.  声明并初始化一个临时子串
        2.  获取当前子串
        3.  进行比较操作
        4.  如果匹配成功，就返回位置
    5. 如果匹配失败，则返回 0
    ```
    // 定位操作（返回 子串T 在 主串S 中第一次出现的位置）
    int Index(const LString &S, const LString &T) {
        // 先判断 子串T 是否是空串
        if(T.length == 0) {
            return 1;  // 空串是任意串的子串
        }

        // 主串不能比子串短
        if(S.length < T.length) {
            return 0;
        }

        // 遍历主串所有可能的起始位置
        for(int pos = 1; pos <= S.length - T.length + 1; pos++) {
            LString sub;  // 暂存子串
            InitString(sub);  // 初始化临时子串

            // 获取当前子串
            if(SubString(sub, S, pos, T.length)) {
                if(StrCompare(sub, T) == 0) {  // 比较是否相等
                    return pos;  // 返回位置
                }
            }
        }
        return 0;  // 未找到，则返回 0
    }
    ```

13. **清空操作**
    1.  传入 **串名 &S**
    2.  新建一个指针，指向 串S 的第一个块
    3.  新建一个指针 temp ，指向 p 指向的结点
    4.  删除 temp 指向的结点
    5.  重置链表状态
    ```
    // 清空操作
    void ClearString(LString &S) {
        Block *p = S.head;  // 新建一个指针，指向 串S 的头指针指向的结点
        while(p) {
            Block *temp = p;
            p = p -> next;
            delete temp;
        }

        // 重置链表状态
        S.head = nullptr;
        S.tail = nullptr;
        S.length = 0;
    }
    ```

14. **销毁串**
    1.  传入 **串名 &S**
    2.  执行清空操作即可
    ```
    // 销毁串
    void DestroyString(LString &S) {
        ClearString(S);  // 清空即销毁
    }
    ```

15. **打印串内容**
    1.  传入 **串名 &S**
    2.  先判断串是否为空
    3.  新建一个指针，指向第一个块
    4.  设置一个计数器，记录当前已打印的字符数
    5.  遍历所有块
        1.  计算当前块的实际字符数。如果当前块是最后一块，就计算最后一块中有多少有效字符
        2.  如果不是最后一块，就存满
        3.  打印当前块的所有有效字符
        4.  把指针移到下一个块
    ```
    // 打印串内容
    void PrintString(const LString &S) {
        // 先判断串是否为空
        if(StrEmpty(S)) {
            std::cout << "串为空" << std::endl;
            return;
        }

        Block *current = S.head;  // 当前块指针
        int count = 0;  // 已打印字符数

        // 遍历所有块
        while(current && count < S.length) {
            // 计算当前块的实际字符数
            int charsInBlock;
            if(current == S.tail) {
                // 如果当前块是最后一块
                // 计算最后一块中有多少字符
                int remainder = S.length % BLOCK_SIZE;
                charsInBlock = (remainder == 0) ? BLOCK_SIZE : remainder;
            }
            else {
                // 如果当前块不是最后一块，就存满
                charsInBlock = BLOCK_SIZE;
            }

            // 打印当前块的有效字符
            for(int i = 0; i < charsInBlock && count < S.length; i++) {
                std::cout << current -> ch[i];
                count++;
            }

            // 移动到下一个块
            current = current -> next;
        }
        std::cout << std::endl;
    }
    ```





# 串的模式匹配
- **模式匹配** ：在 **主串中** 找到与 **模式串** **相同** 的子串，并返回其所在的 **位置** 。

## 朴素模式匹配算法的实现

设 **主串长：n** ，**模式串长：m** **（$n >> m$）** ，则最多需要进行 **$n - m + 1$ 趟** 匹配，每趟最多需要进行 **m 次** 比较，**最坏时间复杂度** 为 **$O(nm)$** 。

1. 首先定义定长顺序存储表示的串的 **最大长度**
    ```
    #define MAX_SIZE 50  // 定义串的最大长度
    ```

2. 定义串的 **定长顺序存储结构**
    ```
    // 串的定长顺序存储结构
    struct SqString {
        char ch[MAX_SIZE];
        int length;
    };
    ```

3. 实现要用到的一些串的 **基本操作**
   1. **初始化串**
        ```
        // 初始化串
        void InitString(SqString &S) {
            S.length = 0;
        }
        ```
    2. **赋值操作**
        ```
        // 赋值操作
        bool StrAssign(SqString &S, const char *chars) {
            // 获取字符数组长
            int len = strlen(chars);

            // 判断字符数组长是否超过最大串长
            if(len > MAX_SIZE - 1) {
                std::cerr << "错误：超过最大串长度" << std::endl;
                return false;
            }

            // 开始赋值
            for(int i = 0; i < len; i++) {
                S.ch[i + 1] = chars[i];
            }

            S.length = len;

            return true;
        }
        ```
    3. **判空操作**
        ```
        // 判空操作
        bool StrEmpty(SqString S) {
            return S.length == 0;
        }
        ```
    4. **打印操作**
        ```
        // 打印操作
        void PrintString(SqString S) {
            // 先判断串是否为空
            if(StrEmpty(S)) {
                std::cout << "串为空" << std::endl;
                return;
            }

            // 打印串内容
            for(int i = 1; i <= S.length; i++) {
                std::cout << S.ch[i];
            }
            std::cout << std::endl;
        }
        ```

4. **朴素模式匹配算法**
   1. 先传入 **主串名 S** 、**模式串名 T**
   2. 设置两个计数器，用来记录当前匹配到 串 S 和 串T 的第几个字符
   3. 从主串第一个字符开始匹配
      1. 如果当前字符相同，就比较后继字符
      2. 如果不相同，就把指针后退重新开始匹配
   4. 如果串T的所有字符都匹配成功，就返回在主串中的位置
   5. 如果所有子串都不匹配，就返回 0
    ```
    // 朴素模式匹配算法
    int Index(const SqString &S, const SqString &T) {
        int i = 1;  // 记录当前比较到 串S 的第几个字符
        int j = 1;  // 记录当前匹配到 串T 的第几个字符
        while(i <= S.length && j <= T.length) {
            if(S.ch[i] == T.ch[j]) {
                // 如果当前字符相同，就比较后继字符
                ++i;
                ++j;
            }
            else {
                // 指针后退重新开始匹配
                i = i - j + 2;
                j = 1;
            }
        }
        // 当前 串T 所有字符都匹配成功，就返回在 串S 中的起始位置
        if(j > T.length)
            return i - T.length;
        else
            return 0;
    }
    ```




## KMP 算法的实现
1. 先定义顺序串的 **最大长度**
    ```
    #define MAX_SIZE 20 // 定义顺序串的最大长度
    ```

2. 定义串的 **定长顺序存储结构** 。
    ```
    // 串的定长顺序存储结构
    struct SqString {
        char ch[MAX_SIZE];
        int length;
    };
    ```

3. 实现需要使用的串的 **基本操作**
   1. **初始化**
        ```
        // 初始化串
        void InitString(SqString &S) {
            S.length = 0;
        }
        ```
    2. **赋值操作**
        ```
        // 赋值操作
        bool StrAssign(SqString &S, const char *chars) {
            // 获取字符数组长
            int len = strlen(chars);

            // 判断字符数组长是否超过最大串长
            if(len > MAX_SIZE - 1) {
                std::cerr << "错误：超过最大串长度" << std::endl;
                return false;
            }

            // 开始赋值
            for(int i = 0; i < len; i++) {
                S.ch[i + 1] = chars[i];
            }

            S.length = len;

            return true;
        }
        ```
    3. **判空操纵**
        ```
        // 判空操作
        bool StrEmpty(SqString S) {
            return S.length == 0;
        }
        ```
    4. **打印操作**
        ```
        // 打印操作
        void PrintString(SqString S) {
            // 先判断串是否为空
            if(StrEmpty(S)) {
                std::cout << "串为空" << std::endl;
                return;
            }

            // 打印串内容
            for(int i = 1; i <= S.length; i++) {
                std::cout << S.ch[i];
            }
            std::cout << std::endl;
        }
        ```
        
4. 求 **next 数组**
   1. 传入 **模式串名 &T** 、**数组 next[]**
   2. 设置一个主串指针，初始化为 1，指向串中第一个字符
   3. 设置一个模式串指针，初始化为 0，指向没有存储字符的零号下标
   4. 先把 next[1] 设置为 0
   5. 从主串的第一个字符开始匹配，如果主串指针超过了模式串的长度，就说明已经计算完成
   6. 如果模式串指针指向 0 ，那么两个指针都先加一，然后然后设置当前位置的 next 值为 1
   7. 如果当前主串和模式串的字符相等，就把两个指针都加一，匹配下一个字符，并记录当前位置的 next 值可以为 j，即当前指向的模式串的值
   8. 如果当前主串和模式串的字符不相等，就把模式串的指针回溯到之前成功匹配的位置
    ```
    // 求 next 数组
    void get_next(const SqString &T, int next[]) {
        int i = 1;  // 主串指针
        int j = 0;  // 模式串指针
        next[1] = 0;  // next[1] 固定为 0

        while(i < T.length) {
            if(j == 0 || T.ch[i] == T.ch[j]) {
                // j 已回溯到起点或匹配成功
                i++;
                j++;
                next[i] = j;  // 设置当前位置的 next 值
            }
            else
                j = next[j];  // 匹配失败，j 回溯
        }
    }
    ```

5. 求 **nextval 数组**
   1. 传入 **模式串名 &T** 、**数组 nextval[]**
   2. 设置一个主串指针，初始为 1，指向主串中第一个字符
   3. 设置一个模式串指针，初始为 0，指向模式串的数组下标为 0 的位置
   4. 把 nextval[1] 设置为 0
   5. 从主串的第一个字符开始匹配，如果主串指针超过了模式串的长度，就说明已经计算完成
   6. 如果模式串指针指向 0 ，那么两个指针都先加一，然后判断主串和模式串当前的字符是否相等，如果不相等，就记录当前位置的 next 为 j ，如果相等就把当前主串位置的 next 值置为 当前模式串位置的 next 值
   7. 如果当前主串和模式串的字符相等，就把两个指针都加一，匹配下一个字符，并记录当前位置的 next 值可以为 j，即当前指向的模式串的值
   8. 如果当前主串和模式串的字符不相等，就把模式串的指针回溯到之前成功匹配的位置
    ```
    // 求 nextval 数组
    void get_nextval(const SqString &T, int nextval[]) {
        int i = 1;  // 主串指针
        int j = 0;  // 模式串指针
        nextval[1] = 0;  // nextval[1] 固定为 0

        while(i < T.length) {
            if(j == 0 || T.ch[i] == T.ch[j]) {
                i++;
                j++;
                if(T.ch[i] != T.ch[j])
                    nextval[i] = j;
                else
                    nextval[i] = nextval[j];
            }
            else
                j = nextval[j];
        }
    }
    ```

6. **KMP 算法**
   1. 传入 **主串名 &S** 、**模式串名 &T** 、**next 数组**
   2. 设置一个主串指针 ，指向主串的第一个字符
   3. 设置一个模式串指针，初始指向模式串的第一个字符
   4. 遍历主串和模式串
   5. 如果匹配成功或者 j 回溯到了起点，就把两个指针都加一
   6. 如果匹配失败就把模式串向右滑动
   7. 如果模式串匹配成功，就返回位置
    ```
    // KMP 算法
    int Index_KMP(const SqString &S, const SqString &T, const int next[]) {
        int i = 1;  // 主串指针
        int j = 1;  // 模式串指针
        while(i <= S.length && j <= T.length) {
            if(j == 0 || S.ch[i] == T.ch[j]) {
                // 匹配成功或 j 已回溯到起点
                i++;
                j++;
            }
            else
                j = next[j];  // 模式串向右移动
        }
        if(j > T.length)
            return i - T.length;  // 匹配成功
        else
            return 0;
    }
    ```