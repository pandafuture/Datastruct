# 绪论
在这里首先介绍 **数据结构的基本概念术语** ，然后说明 **数据结构的三要素** 有哪些，最后介绍 **算法** 和 **度量算法效率的方法**

## 数据结构的基本概念

### 一、 基本概念术语
- **数据** ：信息的载体，是计算机程序加工的原料。

- **数据元素** ：是数据的基本单位，可以由多个 **数据项** 组成。

    - **数据项** ：构成数据元素的不可分割的最小单位。

- **数据对象** ：相同性质的数据元素的集合，是数据的子集。

- **数据类型** ：包括 **值的集合** 和 对这个集合的 **操作** 。
    - **原子类型** ：其值不可再分。
    - **结构类型** ：其值可以再分。
    - **抽象数据类型（ADT）**
    <font color = red>
    可以用抽象数据类型定义一个完整的数据结构。
    </font>

### 二、数据结构三要素
数据结构的三要素是 **数据的逻辑结构** 、 **数据的存储结构** 、 **数据的运算** 。

***注意*** ：数据元素间的关系称为 **结构** 。

1. **逻辑结构** ：数据间的逻辑关系。
    - **线性结构** ：一对一
        - **线性表**
        - **栈** 、 **队列** 、 **串**（受限的线性表）
        - **数组** （线性表的推广）

    - **非线性结构**
        - **集合**
        - **树形结构** ：一对多
        - **图状结构/网状结构** ：多对多

2. **存储结构/物理结构** ：数据结构在计算机中的表示（映射）。
    - **顺序存储** ：逻辑地址相邻，，物理位置也相邻
    - **链式存储** ：物理位置可以不相邻，用 **指针** 表示逻辑关系
    - **索引存储** ：建立 **索引表** ，表中每项为 **索引项（关键字，地址）**
    - **散列存储/哈希存储** ：根据关键字计算存储地址

    ***注意*** ：数据的存储结构会影响 **存储空间分配** 的方便程度，和对数据的 **运算速度** 。

3. **运算**
    - **定义** ：针对逻辑结构，指出运算的 **功能** 。

    - **实现** ：针对存储结构，指出运算的 **具体操作步骤** 。


## 算法

### 一、算法的基本概念
**算法** 描述了解决问题的具体步骤。是 **有穷** 的、**确定** 的、 **可行** 的、 **有零个或多个输入** 、**有一个或多个输出** 。

一个好算法需要 **正确** 、**可读** 、**健壮** 、**高效率且存储量需求低** 。

### 二、度量算法效率
度量算法效率用 **时间复杂度** 和 **空间复杂度** 描述。

#### 1. 计算 **时间复杂度** 
  - 顺序执行的代码只会影响常数项，可以忽略
  - 挑循环中的一个 **基本操作**（最深层循环中的语句）分析它的 **执行次数与 n 的关系**
  - 多项相加，只保留最高阶的项，且系数变为 1
  - 多项相乘则都保留

  <font color = Aqua>
  常见渐近时间复杂度：
  （常对幂指阶）
  </font>

  $O(1)$ < $O(\log_2 n)$ < $O(n)$ < $O(nlog_2 n)$ < $O(n^2)$ < $O(n^3)$ < $O(2^n)$ < $O(n!)$ < $O(n^n)$

  1. 逐步递增型
      ```
      void test(int n) {
          int i = 1;
          while(i <= n) {
              i++;
              printf("%d", i);
          }
          printf("%d", n);
      }

      int main(){
          test(3);
      }
      ```
      - $T(3) = 1 + 4 + 3 + 3 + 1$
      - $T(n) = 3n + 3 = O(n)$

  2. 嵌套循环型
      ```
      void test(int n) {
          int i = 1;
          while(i <= n) {
              i++;
              printf("%d", i);
              for(int j = 1; j <= n; j++) {
                  printf("嵌套循环型");
              }
          }
          printf("%d", n);
      }
      ```
      - $T(n) = O(n) + O(n^2) = O(n)$

  3. 指数递增型
      ```
      void test(int n) {
          int i = 1;
          while(i <= n) {
              i = i * 2;
              printf("%d", i);
          }
          printf("%d", n);
      }
      ```
      - 当循环了 $log_2 n + 1$ 次后，刚好 $2^x > n$ 循环结束
      - $T(n) = O(log_2 n) + O(1) = O(log_2 n)$

  4. 搜索数字型
        ```
        void test(int flag[], int n) {
            for(int i = 0; i < n; i++) {
                if(flag[i] == n) {
                    printf("%d", n);
                    break;
                }
            }
        }

        int main(){
            int flag[n] = {1...n};  // 乱序存放
            test(flag, n);
        }
        ```
        - **最好时间复杂度**： $T(n) = O(1)$
        - **最坏时间复杂度**： $T(n) = O(n)$
        - **平均时间复杂度**： $T(n) = (1 + 2 + 3 + ... + n) {{1}\over {n}} = ({n(1 + n) \over {2}}) {{1} \over {n}} = {{1 + n} \over {2}} = O(n)$

#### 2. 计算 **空间复杂度**
 1. 逐步递增型
     ```
     逐步递增型
     void test(int n) {
         int i = 1;
         while(i <= n) {
             i++;
             printf("逐步递增型", i);
         }
         printf("逐步递增型", n);
     }
     ```
     - n 为 **问题规模**
     - 无论问题规模 n 的值如何改变，算法运行所需的内存空间仍然是固定的常量，则空间复杂度为 $S(n) = O(1)$
     - **算法原地工作** ：算法所需内存空间为常量。

 2. 一个数组
     ```
     void test(int n) {
         int flag[n];
         int i;
         // ......
     }
     ```
     - $S(n) = 4 + 4n + 4 = O(n)$
     - 只要关注那些 **存储空间大小** 是与 **n** 相关的 **变量**
 
 3. 两个数组
     ```
     void test(int n){
         flag[n][n];
         int i;
     }
     ```
     - $S(n) = O(n^2)$
 
 4. 加法规则
     ```
     void test(int n) {
         int flag[n][n];
         int other[n];
         int i;
     }
     ```
     - $S(n) = O(1) + O(n^2) + O(n) = O(n^2)$

 5. 普通常数递归调用
     ```
     void test(int n) {
         int a, b, c;
         if(n > 1) {
             test(n - 1);
         }
         printf("%d", n);
     }

     int main() {
         test(5);
     }
     ```
     - $S(n) = O(n)$
     - 空间复杂度 = 递归调用的深度

 6. 数组递归调用
     ```
     void test(int n) {
         int flag[n];
         if(n > 1) {
             test(n - 1);
         }
         printf("%d", );
     }

     int main(){
         test(5);
     }
     ```
     - $S(n) = O(n^2)$