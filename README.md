# Datastruct
熊猫未来的数据结构学习笔记



# 第一章 线性表

- **线性表** 是一种 *逻辑结构* ，存储 *相同数据类型* 的n个数据元素的有限序列

- 线性表有两种**表示方法**：*顺序表示* 和 *链式表示*

- 用顺序表示的线性表叫 **顺序表**

- 用链式表示的线性表叫 **链表**

- 顺序表中用 *静态分配* 方式实现的叫 **静态顺序表**  
  用 *动态分配* 方式实现的叫 **动态顺序表**

- *链表* 又可以分为 **单链表（带头结点/不带头结点）** 、**双链表**


## 顺序表

### 静态线性表的实现

1. 首先定义线性表的 *最大表容量*

2. 然后设置静态顺序表的 *结构体* ,包括 *数据域* 和 *表长变量*

3. *初始化* 线性表
    1. 传入 *表名*
    2. 初始化 *表长变量为0* 就行

4. *插入操作* ：在第i个位置（指位序）插入元素e
    1. 传入 *表名 L* 、*位序 i* 、*元素 e*  
    <u>注意：对表有修改行为时，有变动的参数前面需要加上&</u>
    2. 判断传入的位序是否合法。不能为0，最大可以插在最后一个元素的后面
    3. 判断表是否已满。就看当前表长有没有到最大表长
    4. 把当前表内第 i 个元素和它后面的元素都往后移一位，从最后一个元素开始移。把前面元素的值赋给后面元素
    5. 把 e 的值赋给第 i 个元素
    6. 表长增一

5. *删除操作* ：删除表中第 i 个位置的元素，并用 e 返回
    1. 传入 *表名 L* 、*位序 i*、 *元素 e*
    2. 判断传入的位序是否合法。不能为0，也不能超过当前表长
    3. 用 e 保存被删除元素的值
    4. 把第 i 个元素后面的所有元素都往前移一位，从第一个元素开始移。把后面元素的值赋给前面元素的值
    5. 表长减一

6. *按值查找* ：查找表中第一个值为 e 的元素的位序，找不到返回 0
    1. 传入 *表名 L* 、*值 e* 
    2. 遍历表中的所有元素（从数组下标0开始）
    3. 如果当前元素值为 e ，则返回当前元素的位序（数组下标加1）
    4. 找不到返回0

7. *按位查找* ：返回表中第 i 个位置的元素的值
    1. 直接返回数组下标为 i - 1 的元素值

8. *遍历打印顺序表* ：按顺序把表里的元素打印出来
    1. 遍历整个表
    2. 遍历时输出元素的值


### 动态顺序表的实现

1. 首先设置动态顺序表的 *结构体* ，包括 *指针* 、*当前最大容量* 、*当前长度* 。指针指向这一片存储空间的开始地址。

2. *初始化* 顺序表
    1. 传入 *表名 L* 、*初始分配大小 size*
    2. 申请 size 个大小为 int 的空间，并用 malloc 函数返回一个强制转换为特定类型的指向这片空间开始地址的指针
    3. 当前最大容量设为 size
    4. 当前长度设为 0

3. *扩容* ：增加容量
    1. 传入 *表名 L* 、 *增加的长度 len*
    2. 新建一个指针，把原指针赋给他，用来保存
    3. 用 malloc 申请一个比原最大容量还大 len 个的空间
    4. 如果分配失败就退出程序
    5. 如果分配成功，就把原数组的元素复制到新数组
    6. 更新当前最大容量
    7. 用 free 方法释放原空间

4. *插入* ：在第 i 个位置插入元素 e。（与静态顺序表相同）

5. *删除* ：删除第 i 个元素，并用 e 返回（与静态顺序表相同）

6. *按值查找* ：查找表中第一个值为 e 的元素的位序，找不到返回 0（与静态顺序表相同）

7. *按位查找* ：返回表中第 i 个位置的元素的值（与静态顺序表相同）

8. *遍历打印顺序表* （与静态顺序表相同）


## 链表

### 单链表

#### 带头结点的单链表的实现

1. 首先定义单链表的 *结点结构*。
    - 包括一个 *数据域* 和一个结点类型 *指针域*。这个指针指向的是下一个结点的空间地址  

2. *初始化* 带头结点的单链表
    1. 传入 *头指针 \*&L* 的值。
         - 因为初始化要创建一个头结点，也就是说头指针 L 的值从 nullptr 指向了新创建的头结点，所以修改了 L 的值那就要加返回符 *&*。  
        - <u>头指针是一个单链表的标识</u>
    2. 创建一个 *头结点 L*。
    3. 把头结点 L 的 *next 指向 nullptr*

3. *头插法* 插入新结点 e ：把新元素都插到头结点的后一个位置上
    1. 传入 *头指针 \*L* 、*新结点 e* 。
        - 因为是带头结点的单链表，所以头指针的值不会变，始终指向头结点，因此不用带返回符 &
    2. 新建一个结点 s
    3. 把 e 的值赋给 s 的数据域
    4. 把 s 的 next 指向头结点 L 的 next 域
    5. 头结点 L 的 next 指向 s

4. *尾插法* 插入新结点 e ：把新结点插到链表的末尾
    1. 传入 *头指针 \*L* 、*新结点 e*
    2. 新建一个结点 s 
    3. 把 e 的值赋给 s 的数据域
    4. 把 s 的 next 指向 nullptr
    5. 新建一个指针 *p ，并让他指向头结点 L
    6. 找到尾结点
        - 遍历整个链表，直到 p 的 next 为 nullptr ，表示当前结点为尾结点
    7. 把尾结点 p 的 next 指向 s

5. *按位删除* （删除第 i 个位置的结点，并用 e 返回）
    1. 传入 *头指针 \*L* 、*位置 i* 、*返回值 &e*
    2. 判断输入是否合法。 i 的值不能为 0
    3. 新建一个指针 *p ，让它指向头结点 L
    4. 设置一个计数器 j , 表示当前指向第几个结点。默认设为 0（头结点表示为 0 ）
    5. 找到被删除结点的前一个结点
        - 遍历整个链表，直到 j = i-1，表示当前结点为被删除结点的前一个结点
        - 如果遍历时 指针 p 的 next 指向了 nullptr 即指向了最后一个元素，则说明输入的位置超过了表长
    6. 再新建一个指针 *q ,让它指向被删除的结点 p -> next
    7. 用 e 记录被删除结点 p 的数据域的值
    8. 把被删除结点的前一个结点 p 的 next 指向 被删除结点 q 的下一个结点
    9. 释放被删除结点 p 的空间

6. *遍历打印单链表*
    1. 传入 *头指针 \*L*
    2. 新建一个指针 *p ，并让它指向头结点的下一个结点
    3. 遍历整个单链表，同时打印当前结点的数据域，直到指针指向 nullptr


#### 不带头结点的单链表的实现

1. 首先定义单链表的 *结点结构*
    - 包括一个 *数据域* 和一个 *指针域*，这个指针指向的是下一个结点的空间地址

2. *初始化* 单链表
    1. 传入 *头指针 \*&L*
    2. 让头指针 L 指向 nullptr

3. *插入* （在第 i 个位置插入 e ）
    1. 传入 *头指针 \*&L* ， *插入位置 i*， *返回值 e*
    2. 判断输入是否合法，位置 i 不能小于 1
    3. 如果是在表头位置插入
        1. 新建一个结点 s
        2. 把 e 的值赋给 s 的数据域
        3. 让 s 的 next 指向当前的第一个结点 L
        4. 让头指针 L 指向 s
    4. 如果不是插在表头位置
        1. 新建一个结点 s
        2. 把 e 的值赋给 s 的数据域
        3. 找到第 i-1 个结点
            - 创建一个指针 *p ,指向头结点
            - 设置一个计数器，记录当前指向第几个结点，初始设为 1 （没有头结点）
            - 遍历这个链表，直到 j = i-1 ，表示找到了第 i-1 个结点
            - 如果指针 p 指向 nullptr ，则说明插入位置超过了 表长+1
        4. 把 s 的 next 指向 p 的 next 即指向第 i 个位置的结点
        5. 让 p 的 next 指向 s ，即把 p 和 s 连起来

4. *删除* （删除第 i 个位置的结点，并用 e 返回）
    1. 传入 *头指针 \*&L* ，*删除位置 i* ， *返回值 e*
    2. 判断删除位置是否合法， i 不能小于 1
    3. 如果删除第一个结点
        1. 新建一个指针 *p ，指向第一个结点 L
        2. 用 e 保存头结点的值
        3. 让头指针 L 指向第二个结点 L -> next
        4. 释放 p 指针的空间
    4. 如果删除的是其他结点，那就找到被删除结点的前一个结点
        1. 新建一个指针 *p ,指向第一个结点
        2. 设置一个计数器， 表示当前指向第几个结点，默认设为 1 （没有头结点）
        3. 遍历整个链表，直到找到第 i-1 个结点
            - 如果 p -> next 等于 nullptr ，那就表示传入的位置超出了表长
        4. 新建一个指针 *q ,指向被删除的结点 p -> next
        5. 用 e 返回被删除结点的值 q -> data
        6. 把被删除结点的前一个结点的 next 指向被删除结点 q 的 next
        7. 释放被删除结点的空间 q

5. *遍历打印单链表*
    1. 传入 *头指针 \*L*
    2. 新建一个指针 *p ，指向第一个节点 L
    3. 遍历整个链表，同时输出当前结点的值，直到 p 为空


### 双链表的实现

1. 首先定义双链表的 *结点结构* 。包括一个 *数据域* 、*指向前驱的指针* 、*指向后继的指针*

2. *初始化*
    1. 创建一个头结点 L
    1. 传入 *头指针 \*&L* ，让头指针指向头结点
    2. 把前驱指针 prior 指向 nullptr (头结点的前驱指针 prior 永远指向空)，把后继指针 next 指向空，因为当前没有其他结点

3. *插入* （在第 i 个位置插入结点 e ）
    1. 传入 *头指针 L* 、*插入位置 i* 、*插入的值 e*
    2. 判断插入位置是否合法，i 不能为0
    3. 找到插入位置的前一个结点
        1. 新建一个指针 p，指向头结点
        2. 设置一个计数器，记录当前指向第几个结点，默认设为 0 （头结点记为 0 ）
        3. 遍历整个链表，直到 j = i-1
        4. 如果 p 指向空，即插入位置的前一个结点为空，就说明插入位置超过了表长
    4. 新建一个结点 s
    5. 把 e 的值赋给 s 的数据域
    6. 让新结点 s 的 next 指向 p 的 next
    7. 如果 p 结点后面还有结点，那么就把 p 后面的结点的 prior 指向 s
    8. 把 s 的 prior 指向 p 结点
    9. 把 p 结点的 next 指向 s

4. *删除* （删除第 i 个位置的结点，并用 e 返回）
    1. 传入 *头指针 L* 、*删除位置 i* 、*返回值 e*
    2. 判断删除位置是否合法，i 不能为 0
    3. 找第 i 个位置的结点
        1. 新建一个指针 p ，让它指向头结点之后的第一个结点
        2. 设置一个计数器，记录当前指向第几个结点。默认为 1（指向头结点之后的第一个结点）
        3. 遍历整个链表，直到 j = i
        4. 如果遍历过程中 p 指向空，则说明第 i 个位置没有结点，输入的位置 i 不合法
    4. 直到第 i 个结点后，用 e 返回 p 的值
    5. 再把结点 p 的前一个结点的 next 指向 p 的后一个结点
    6. 如果 p 结点后还有结点，就把后面的这个结点的 prior 指向 p 的前一个结点
    7. 释放被删除结点 p 的空间