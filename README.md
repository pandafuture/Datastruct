# Datastruct
熊猫未来的数据结构学习笔记



# 第一章 线性表

- **线性表** 是一种 *逻辑结构* ，存储 *相同数据类型* 的n个数据元素的有限序列

- 线性表有两种**表示方法**：*顺序表示* 和 *链式表示*

- 用顺序表示的线性表叫 **顺序表**

- 用链式表示的线性表叫 **链表**

- 顺序表中用 *静态分配* 方式实现的叫 **静态顺序表**  
  用 *动态分配* 方式实现的叫 **动态顺序表**

- *链表* 又可以分为 **单链表（带头结点/不带头结点）**


## 顺序表

### 静态线性表的实现

1. 首先定义线性表的 *最大表容量*

2. 然后设置静态顺序表的 *结构体* ,包括 *数据域* 和 *表长变量*

3. *初始化* 线性表
    1. 传入 *表名*
    2. 初始化 *表长变量为0* 就行

4. *插入操作* ：在第i个位置（指位序）插入元素e
    1. 传入 *表名 L* 、*位序 i* 、*元素 e*  
    <u>注意：对表有修改行为时，有变动的参数前面需要加上&</u>
    2. 判断传入的位序是否合法。不能为0，最大可以插在最后一个元素的后面
    3. 判断表是否已满。就看当前表长有没有到最大表长
    4. 把当前表内第 i 个元素和它后面的元素都往后移一位，从最后一个元素开始移。把前面元素的值赋给后面元素
    5. 把 e 的值赋给第 i 个元素
    6. 表长增一

5. *删除操作* ：删除表中第 i 个位置的元素，并用 e 返回
    1. 传入 *表名 L* 、*位序 i*、 *元素 e*
    2. 判断传入的位序是否合法。不能为0，也不能超过当前表长
    3. 用 e 保存被删除元素的值
    4. 把第 i 个元素后面的所有元素都往前移一位，从第一个元素开始移。把后面元素的值赋给前面元素的值
    5. 表长减一

6. *按值查找* ：查找表中第一个值为 e 的元素的位序，找不到返回 0
    1. 传入 *表名 L* 、*值 e* 
    2. 遍历表中的所有元素（从数组下标0开始）
    3. 如果当前元素值为 e ，则返回当前元素的位序（数组下标加1）
    4. 找不到返回0

7. *按位查找* ：返回表中第 i 个位置的元素的值
    1. 直接返回数组下标为 i - 1 的元素值

8. *遍历打印顺序表* ：按顺序把表里的元素打印出来
    1. 遍历整个表
    2. 遍历时输出元素的值


### 动态顺序表的实现

1. 首先设置动态顺序表的 *结构体* ，包括 *指针* 、*当前最大容量* 、*当前长度* 。指针指向这一片存储空间的开始地址。

2. *初始化* 顺序表
    1. 传入 *表名 L* 、*初始分配大小 size*
    2. 申请 size 个大小为 int 的空间，并用 malloc 函数返回一个强制转换为特定类型的指向这片空间开始地址的指针
    3. 当前最大容量设为 size
    4. 当前长度设为 0

3. *扩容* ：增加容量
    1. 传入 *表名 L* 、 *增加的长度 len*
    2. 新建一个指针，把原指针赋给他，用来保存
    3. 用 malloc 申请一个比原最大容量还大 len 个的空间
    4. 如果分配失败就退出程序
    5. 如果分配成功，就把原数组的元素复制到新数组
    6. 更新当前最大容量
    7. 用 free 方法释放原空间

4. *插入* ：在第 i 个位置插入元素 e。（与静态顺序表相同）

5. *删除* ：删除第 i 个元素，并用 e 返回（与静态顺序表相同）

6. *按值查找* ：查找表中第一个值为 e 的元素的位序，找不到返回 0（与静态顺序表相同）

7. *按位查找* ：返回表中第 i 个位置的元素的值（与静态顺序表相同）

8. *遍历打印顺序表* （与静态顺序表相同）


## 链表

### 单链表

#### 带头结点的单链表的实现

1. 首先定义单链表的 *结点结构*。
    - 包括一个 *数据域* 和一个结点类型 *指针域*。这个指针指向的是下一个结点的空间地址  

2. *初始化* 带头结点的单链表
    1. 传入 *头指针 \*&L* 的值。
         - 因为初始化要创建一个头结点，也就是说头指针 L 的值从 nullptr 指向了新创建的头结点，所以修改了 L 的值那就要加返回符 *&*。  
        - <u>头指针是一个单链表的标识</u>
    2. 创建一个 *头结点 L*。
    3. 把头结点 L 的 *next 指向 nullptr*

3. *头插法* 插入新结点 e ：把新元素都插到头结点的后一个位置上
    1. 传入 *头指针 \*L* 、*新结点 e* 。
        - 因为是带头结点的单链表，所以头指针的值不会变，始终指向头结点，因此不用带返回符 &
    2. 新建一个结点 s
    3. 把 e 的值赋给 s 的数据域
    4. 把 s 的 next 指向头结点 L 的 next 域
    5. 头结点 L 的 next 指向 s

4. *尾插法* 插入新结点 e ：把新结点插到链表的末尾
    1. 传入 *头指针 \*L* 、*新结点 e*
    2. 新建一个结点 s 
    3. 把 e 的值赋给 s 的数据域
    4. 把 s 的 next 指向 nullptr
    5. 新建一个指针 *p ，并让他指向头结点 L
    6. 找到尾结点
        - 遍历整个链表，直到 p 的 next 为 nullptr ，表示当前结点为尾结点
    7. 把尾结点 p 的 next 指向 s

5. *按位删除* （删除第 i 个位置的结点，并用 e 返回）
    1. 传入 *头指针 \*L* 、*位置 i* 、*返回值 &e*
    2. 判断输入是否合法。 i 的值不能为 0
    3. 新建一个指针 *p ，让它指向头结点 L
    4. 设置一个计数器 j , 表示当前指向第几个结点。默认设为 0（头结点表示为 0 ）
    5. 找到被删除结点的前一个结点
        - 遍历整个链表，直到 j = i-1，表示当前结点为被删除结点的前一个结点
        - 如果遍历时 指针 p 的 next 指向了 nullptr 即指向了最后一个元素，则说明输入的位置超过了表长
    6. 再新建一个指针 *q ,让它指向被删除的结点 p -> next
    7. 用 e 记录被删除结点 p 的数据域的值
    8. 把被删除结点的前一个结点 p 的 next 指向 被删除结点 q 的下一个结点
    9. 释放被删除结点 p 的空间

6. *遍历打印单链表*
    1. 传入 *头指针 \*L*
    2. 新建一个指针 *p ，并让它指向头结点
    3. 设置一个计数器 j ，表示当前指向第几个结点，默认设为 0 （头结点为 0 ）
    4. 遍历整个单链表，同时打印当前结点的数据域，直到指针指向 nullptr