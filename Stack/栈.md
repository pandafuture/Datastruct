# 栈

- **栈** 是只允许在一端插入或者删除的线性表。

- **栈顶** ：允许插入和删除的一端

- **栈底** ：不允许插入和删除的一端

- **空栈** ：空表

- **栈的特点** ：**后进先出（FIFO）**

- **栈的基本操作**
  - **初始化**
  - **销毁**
  - **进栈**
  - **出栈**
  - **读栈顶元素**
  - **判空**

- **栈的数学性质** ：n 个不同元素入栈时，出栈元素不同排列的个数为 **${1\over{n+1}}C^n_{2n}$** （卡特兰数）

- 栈有两种存储方式：**顺序存储结构** 和 **链式存储结构**

- 采用顺序存储的栈称为 **顺序栈**

- 采用链式存储的栈称为 **链表**

- 顺序栈中还包括了 **共享栈**





# 顺序栈的实现
1. 首先定义 **栈的最大容量**
    ```
    #define MAX_SIZE 100  // 定义栈的最大容量
    ```

2. 定义 **顺序栈结构体**
   - 包括 **存放栈中元素的数组** 和 记录栈顶元素的数组下标的 **栈顶“指针”**
    ```
    // 顺序栈结构体
    struct SequenceStack {
        int data[MAX_SIZE];  // 存储栈元素的数组
        int top;  // 栈顶“指针” ，指向栈顶元素的数组下标
    };
    ```

3. **初始化**
   1. 传入 **栈名 &S**
   2. 把 **栈顶“指针”** 初始化为 **-1** ，表示空栈
    ```
    // 初始化
    void InitStack(SequenceStack &S) {
        S.top = -1;  // 栈顶“指针”初始化为 -1 ，表示空栈
    }
    ```

4. **判空**
   1. 传入 **栈名 S**
   2. 直接返回栈顶指针是否指向 -1
    ```
    // 判空
    bool Empty(SequenceStack S) {
        return S.top == -1;  // 直接返回栈顶“指针”是否为 -1
    }
    ```

5. **判满**
   1. 传入 **栈名 S**
   2. 直接返回栈顶指针是否为最大容量减一，若是，则栈满；若不是，则栈未满。
    ```
    // 判满
    bool Full(SequenceStack S) {
        return S.top == MAX_SIZE - 1;  // 直接返回栈顶“指针”是否为最大表长 - 1
    }
    ```

6. **入栈操作**
   1. 传入 **栈名 &S** 、**要入栈的元素 e**
   2. 先判断栈是否已满
   3. 先把栈顶“指针”加一后，再把元素 e 入栈
    ```
    // 入栈操作
    bool Push(SequenceStack &S, int e) {
        // 先判断栈是否已满
        if(Full(S)) {
            std::cout << "栈已满" << std::endl;
            return false;
        }

        S.data[++S.top] = e;  // 栈顶“指针”先加一，然后入栈
        return true;
    }
    ```

7. **出栈操作**
   1. 传入 **栈名 S** 、**返回值 &e**
   2. 先判断栈是否为空
   3. 然后读取栈顶元素的值，再把栈顶“指针”减一
    ```
    // 出栈操作
    bool Pop(SequenceStack &S, int &e) {
        // 先判断栈是否为空
        if(Empty(S)) {
            std::cout << "栈为空" << std::endl;
            return false;
        }

        e = S.data[S.top--];  // 读取出栈顶元素的值，然后指针减一
        return true;
    }
    ```

8. **读栈顶元素**
   1. 传入 **栈名 S** 、**返回值 &e**
   2. 先判断栈是否为空
   3. 获取栈顶元素的值
    ```
    // 读栈顶元素
    bool GetTop(SequenceStack S, int &e) {
        // 先判断栈是否为空
        if(Empty(S)) {
            std::cout << "栈为空" << std::endl;
            return false;
        }

        e = S.data[S.top];  // 获取栈顶元素的值
        return true;
    }
    ```

9. **输出栈**
   1.  传入 **栈名 S**
   2.  先判断栈是否为空
   3.  再从栈顶开始遍历整个栈，同时打印每个元素的值
    ```
    // 打印栈
    void PrintStack(SequenceStack S) {
        // 先判断栈是否为空
        if(Empty(S)) {
            std::cout << "栈为空" << std::endl;
            return;
        }

        // 从栈顶开始遍历整个栈，同时打印每个元素的值
        for (int i = S.top; i >= 0; i--) {
            std::cout << S.data[i] << " ";
        }
        std::cout << std::endl;
    }
    ```

10. **销毁操作**
    1. 对于静态数组实现的栈，只需要把栈顶指针重置就行
    ```
    // 销毁操作
    void DestroyStack(SequenceStack &S) {
        S.top = -1;  // 对于静态数组实现的栈，只需要重置栈顶指针
    }
    ```





# 共享栈的实现
1. 先定义共享栈的 **最大容量**
    ```
    #define MAX_SIZE 100  // 共享栈的总容量
    ```

2. 定义 **共享栈结构体**
    1. 先设置一个存储栈元素的 **数组**
    2. 再设置一个 **栈 1** 的 **栈顶“指针”**
    3. 再设置一个 **栈 2** 的 **栈顶“指针”**
    ```
    // 共享栈结构体
    struct SharedStack {
        int data[MAX_SIZE];  // 存储栈元素的数组
        int top1;  // 栈1 的栈顶“指针”
        int top2;  // 栈2 的栈顶“指针”
    };
    ```

3. **初始化**
   1. 传入 **栈名 &S**
   2. **初始化栈顶指针**
      1. 栈1 栈顶指针初始化为 -1 ，因为 栈1 的栈底为 0
      2. 栈2 栈顶指针初始化为 MAX_SIZE ，因为 栈2 的栈底为 MAX_SIZE
    ```
    // 初始化共享栈
    void InitSharedStack(SharedStack &S) {
        S.top1 = -1;  // 栈1 初始化为空（从数组左端开始）
        S.top2 = MAX_SIZE;  // 栈2 初始化为空（从数组右端开始）
    }
    ```

4. **判空**
   1. 栈1
      1. 传入 **栈名 S**
      2. 直接返回栈1的栈顶指针是否指向 -1
        ```
        // 判空
        bool Empty1(SharedStack S) {
            return S.top1 == -1;  // 直接返回栈1的栈顶指针是否为 -1
        }
        ```
   2. 栈2
      1. 传入 **栈名 S**
      2. 直接返回栈2的栈顶指针是否指向 MAX_SIZE
        ```
        bool Empty2(SharedStack S) {
            return S.top2 == MAX_SIZE;  // 直接返回栈2的栈顶指针是否为初始值
        }        
        ```

5. **判满**
   1. 传入 **栈名 S**
   2. 看两个栈顶指针是否相邻，如果相邻就说明栈满，不相邻，则栈未满
    ```
    // 判满
    bool Full(SharedStack S) {
        return S.top1 + 1 == S.top2;  // 两个栈顶相邻表示栈满
    }
    ```

6. **入栈**
   1. 栈1
      1. 传入 **栈名 &S** 、**要入栈的元素 e**
      2. 先判断栈是否已满
      3. 未满则把 **栈顶指针先加一** ，再把元素入栈
        ```
        bool Push1(SharedStack &S, int e) {
            // 先判断栈是否已满
            if(Full(S)) {
                std::cout << "栈已满";
                return false;
            }

            S.data[++S.top1] = e;  // 栈1 栈顶“指针”先加一，再入栈
            return true;
        }
        ```
    2. 栈2
       1. 传入 **栈名 &S** 、**要入栈的元素 e**
       2. 先判断栈是否已满
       3. 未满则先把 **栈顶指针减一** ，再把元素入栈
        ```
        bool Push2(SharedStack &S, int e) {
            // 先判断栈是否已满
            if(Full(S)) {
                std::cout << "栈已满";
                return false;
            }

            S.data[--S.top2] = e;  // 栈2 栈顶“指针”先减一，在入栈
            return true;
        }
        ```

7. **出栈**
   1. 栈1
      1. 传入 **栈名 &S** 、**返回值 &e**
      2. 先判断栈1是否为空
      3. 先读取栈顶元素，然后把栈顶指针减一
        ```
        bool Pop1(SharedStack &S, int &e) {
            // 先判断栈1是否为空
            if(Empty1(S)) {
                std::cout << "栈1为空";
                return false;
            }

            e = S.data[S.top1--];  // 读取栈顶元素值，再把栈1栈顶“指针”减一
            return true;
        }
        ```
    2. 栈2
       1. 传入 **栈名 &S** 、**返回值 &e**
       2. 先判断栈2是否为空
       3. 读取栈顶元素，再把栈顶指针加一
        ```
        bool Pop2(SharedStack &S, int &e) {
            // 先判断栈2是否为空
            if(Empty2(S)) {
                std::cout << "栈2为空";
                return false;
            }

            e = S.data[S.top2++];  // 读取栈2栈顶元素值，再把栈2栈顶“指针”加一
            return true;
        }
        ```

8. **读栈顶元素**
   1. 栈1
      1. 传入 **栈名 S** 、**返回值 &e**
      2. 先判断栈1是否为空
      3. 读取栈顶元素
        ```
        // 读栈顶元素
        bool GetTop1(SharedStack S, int &e) {
            // 先判断栈1是否为空
            if(Empty1(S)) {
                std::cout << "栈1为空";
                return false;
            }

            e = S.data[S.top1];  // 读取栈1的栈顶元素
            return true;
        }
        ```
    2. 栈2
       1. 传入 **栈名 S** 、**返回值 &e**
       2. 先判断栈2是否为空
       3. 读取栈2的栈顶元素
        ```
        bool GetTop2(SharedStack S, int &e) {
            // 先判断栈2是否为空
            if(Empty2(S)) {
                std::cout << "栈2为空";
                return false;
            }

            e = S.data[S.top2];  // 读取栈2的栈顶元素
            return true;
        }
        ```

9. **输出栈**
   1.  传入 **栈名 S**
   2.  先判断栈1是否为空，若不为空，则从栈顶开始遍历整个栈1，同时输出每个元素
   3.  再判断栈2是否为空，若不为空，则从栈顶开始遍历整个栈2，同时输出每个元素
    ```
    // 输出栈
    void PrintSharedStack(SharedStack S) {
        std::cout << "输出栈1: ";
        // 先判断栈 1 是否为空
        if(Empty1(S)) {
            std::cout << "栈1为空";
        }
        else {
            // 不为空，则从栈1的栈顶开始遍历整个栈1，同时输出元素
            for (int i = S.top1; i >= 0; i--) {
                std::cout << S.data[i] << " ";
            }
        }
        std::cout << std::endl;

        std::cout << "输出栈2: ";
        // 先判断栈2 是否为空
        if(Empty2(S)) {
            std::cout << "栈2为空";
        }
        else {
            // 不为空，则从栈2的栈顶开始遍历整个栈2，同时输出元素
            for (int i = S.top2; i < MAX_SIZE; i++) {
                std::cout << S.data[i] << " ";
            }
        }
        std::cout << std::endl;
    }
    ```

10. **求栈长**
    1.  栈1
        1.  传入 **栈名 S**
        2.  直接返回指针值加一
        ```
        int Length1(SharedStack S) {
            return S.top1 + 1;
        }        
        ```
    2. 栈2
       1. 传入 **栈名 S**
       2. 直接返回最大表长减栈顶指针值
        ```
        int Length2(SharedStack S) {
            return MAX_SIZE - S.top2;
        }
        ```

11. **销毁操作**
    1.  传入 **栈名 &S**
    2.  重置栈1的栈顶指针为 -1
    3.  重置栈2的栈顶指针为 MAX_SIZE
    ```
    // 销毁栈
    void DestroySharedStack(SharedStack &S) {
        S.top1 = -1;  // 重置栈1
        S.top2 = MAX_SIZE;  // 重置栈2
    }
    ```