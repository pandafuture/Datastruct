# 串
- **字符串（串）** 是由 0 个或多个字符组成的有限序列。

- 串的数据对象限定为 **字符集**

- **串名**

- **串的值** ：单引号（双引号）括起来的字符序列内容

- **串的长度** ：串中字符的个数 n 。n 为 0 时串为 **空串**（用 $\emptyset$ 表示）

- **子串** ：串中 **任意多个** **连续** 的字符组成的子序列。（空串也是子串）

- **主串** ：包含子串的串

- **字符在串中的位置** ：某个字符在串中的序号（从 1 开始）

- **子串在主串中的位置** ：子串的第一个字符在主串中的位置

- **两个串相等** ：两个串的长度相等，且每个对应位置的字符都相等

- **空格串** ：一个或多个空格组成的串。（空格串不是空串）

- 串的 **基本操作** （以子串作为操作对象）
  - **赋值操作**
  - **复制操作**
  - **判空操作**
  - **比较操作**
  - **求串长**
  - **求子串**
  - **串联接**
  - **定位操作**
  - **清空操作**
  - **销毁串**





# 串的顺序存储的实现
## 定长顺序存储（使用静态数组）
1. 先 **预定义串的最大长度**
    ```
    #define MAX_SIZE 255  // 预定义最大串长为 255
    ```

2. 定义串的 **存储结构** 。
   1. 使用 **静态数组** 存储串字符。每个分量都存储一个字符，除了 **char[0] 不使用**
   2. 设置一个整型变量，用来记录串的 **实际长度**
    ```
    // 串的顺序存储结构（使用静态数组实现）
    struct SqString {
        char ch[MAX_SIZE];  // 存储串字符的数组，每个分量存储一个字符（ch[0] 不使用）
        int length;  // 串的实际长度（从 1 开始存储）
    };
    ```

3. **初始化串**
   1. 传入 **串名 &S**
   2. 只需把 **串长设为 0** ，表示空串。
    ```
    // 初始化串（创建空串）
    void InitString(SqString &S) {
        S.length = 0;  // 长度设为 0，表示空串
    }
    ```

4. **赋值操作** ：把 **chars** 赋值给 **串S**
   1. 传入 **串名S** 、 **字符串 const char *chars** （表示不可改变指针指向的字符内容）
   2. 计算输入字符数组的 **长度**
   3. 先检查输入长度 **是否超过最大容量**（实际可用最大容量为 **MAX_SIZE - 1**）
   4. 从 char[1] 开始存放赋值内容
   5. 更新串长度
    ```
    bool StrAssign(SqString &S, const char *chars) {
        int len = strlen(chars);  // 计算输入字符数组的长度
        // 检查输入长度是否超过最大容量（实际可用长度为 MAX_SIZE-1）
        if(len > MAX_SIZE - 1) {
            std::cerr << "错误：超过最大串长度" << std::endl;
            return false;
        }

        // 开始赋值（从 char[1] 开始存放）
        for(int i = 0; i < len; i++) {
            S.ch[i + 1] = chars[i];  // 第几个位序的字符就放在数组中的第几个下标位置
        }
        S.length = len;  // 更新串长度
        return true;
    }
    ```

5. **复制操作** ：把 **串T** **复制给** **串S**
   1. 先传入 **串S的串名 &S** 、**串T的串名 T**
   2. 检查 串T **是否为空**
   3. 如果串T为空，就只需把串S初始化为空串即可
   4. 如果串T不为空，就从 char[1] 开始逐字符复制内容到串S
   5. 更新串长
    ```
    // 复制操作（把串 T 复制给串 S）
    bool StrCopy(SqString &S, const SqString T) {
        // 检查源串是否为空
        if(T.length == 0) {
            // 如果为空，就只要把目标串初始化为空就行
            InitString(S);
            return true;
        }

        // 开始复制内容（从 char[1] 开始）
        for(int i = 1; i <= T.length; i++) {
            S.ch[i] = T.ch[i];  // 逐字符复制
        }
        S.length = T.length;  // 更新串长度
        return true;
    }
    ```

6. **判空**
   1. 直接返回串的长度是否为 0
    ```
    // 判空操作
    bool StrEmpty(SqString S) {
        return S.length == 0;  // 长度为 0 即为空串
    }
    ```

7. **比较操作** ：若 S > T，则返回值 > 0；若S = T，则返回值 = 0；若 S < T，则返回值 < 0
   1. 传入要比较的 **串名 S，T**
   2. 从下标 1 开始，逐字符比较
   3. 返回第一个不同字符的差值
   4. 如果所有字符都相同，就比较长度
    ```
    // 比较操作（若 S > T，则返回值大于 0；若 S = T，则返回值等于 0；若 S < T，则返回值小于 0）
    int StrCompare(SqString S, SqString T) {
        // 逐字符比较（从下标 1 开始）
        for(int i = 1; i <= (S.length < T.length ? S.length : T.length); i++) {
            if(S.ch[i] != T.ch[i])
                return S.ch[i] - T.ch[i];  // 返回第一个不同字符的差值
        }
        return S.length - T.length;  // 所有字符都相同，则比较长度
    }
    ```

8. **求串长**
   1. 直接返回长度
    ```
    // 求串长
    int StrLength(SqString S) {
        return S.length;  // 直接返回长度
    }
    ```

9. **求子串** ：用 Sub 返回 串S 的第 pos 个字符起长度为 len 的字符
   1. 传入 **子串名 &Sub** 、**主串名 S** 、**起始位置 pos** 、**子串长度 len**
   2. 首先检查起始位置和子串长度是否越界
   3. 然后再截取子串内容
   4. 最后更新子串长度
    ```
    // 求子串（用 Sub 返回 串S 的第 pos 个字符起长度为 len 的子串）
    bool SubString(SqString &Sub, SqString S, int pos, int len) {
        // 检查位置和子串长度是否越界
        if(pos < 1 || pos > S.length || len < 0 || pos + len - 1 > S.length) {
            std::cerr << "错误：非法位置或长度" << std::endl;
            return false;
        }

        // 截取子串内容
        for(int i = 1; i <= len; i++) {
            Sub.ch[i] = S.ch[pos + i - 1];
        }
        Sub.length = len;
        return true;
    }
    ```

10. **串联接** ：把串S1和串S2联接成新串T
    1. 传入 **新串名 &T** 、**要连接的串名 S1，S2**
    2. 检查两个串的总长度是否超过定义的最大长度。（实际最大使用长度为 MAX_SIZE - 1）
    3. 复制第一个串的内容
    4. 复制第二个串的内容，接在第一个串后面
    5. 更新串T的串长
    ```
    // 串联接（将 串S1 和 串S2 联接成新串T）
    bool Concat(SqString &T, SqString S1, SqString S2) {
        // 检查总长度是否超过最大长度
        if(S1.length + S2.length >  MAX_SIZE - 1) {
            std::cerr << "错误：联接后串超过最大长度" << std::endl;
            return false;
        }

        // 复制第一个串的内容
        for(int i = 1; i <= S1.length; i++) {
            T.ch[i] = S1.ch[i];
        }

        // 复制第二个串的内容（接在第一个串后面）
        for(int i = 1; i <= S2.length; i++) {
            T.ch[S1.length + i] = S2.ch[i];
        }

        T.length = S1.length + S2.length;  // 更新串长度
        return true;
    }
    ```

11. **定位操作** ：若主串S中存在与串T值相同的子串，则返回它再主串S中第一次出现的位置；否则返回 0
    1. 首先传入 **主串名 S** 、**要定位的子串名 T**
    2. 先判断子串如果是空串，就直接返回 0
    3. 如果不是空串就获取两个串的长度
    4. 然后从主串的第一个字符开始获取长度为子串长度的子串，并暂存再 sub 中
    5. 把 sub 中暂存的子串和目标子串进行比较操作，如果不同，则继续，如果相同，则返回子串再主串中的位置
    6. 如果没找到就返回 0
    ```
    // 定位操作（若 主串S 中存在与 串T 值相同的子串，则返回它在主串S中第一次出现的位置；否则返回 0）
    int Index(SqString S, SqString T) {
        // 空串是任意串的子串
        if(T.length == 0)
            return 0;

        int n = StrLength(S);  // 获取 串S 的长度
        int m = StrLength(T);  // 获取 串T 的长度
            
        int i = 1;
        SqString sub;  // 用于暂存子串
        // 从 串S 的第一个字符开始获取长度为 m 的子串，并暂存在 串sub 中
        while(i <= n - m + 1) {
            SubString(sub, S, i, m);  // 获取子串
            if(StrCompare(sub, T) != 0)  // 进行比较
                ++i;
            else return i;  // 返回子串在主串中的位置
        }
        return 0;  // 如果没找到就返回 0
    }
    ```

12. **清空操作**
    1.  传入 **要清空的串名 &S**
    2.  把长度设置为 0，即为空串
    ```
    // 清空操作
    void ClearString(SqString &S) {
        S.length = 0;  // 长度重置为 0，即为空串
    }
    ```

13. **销毁串**
    1.  传入 **要销毁的串名 &S**
    2.  静态数组无需是否内存，只需要清空就行
    ```
    // 销毁串
    void DestroyString(SqString &S) {
        // 静态数组无需释放内存，等同于清空
        ClearString(S);
    }
    ```

14. **打印串的内容**
    1.  传入 **要打印的串名 S**
    2.  先判断串是否为空
    3.  从 char[1] 开始打印串内容
    ```
    // 打印串内容
    void PrintString(SqString S) {
        // 先判断串是否为空
        if(StrEmpty(S)) {
            std::cout << "串为空" << std::endl;
            return;
        }

        // 打印串内容（从下标1开始打印）
        for(int i = 1; i <= S.length; i++) {
            std::cout << S.ch[i];
        }
        std::cout << std::endl;
    }
    ```