# 第一章 线性表

- **线性表** 是一种 **逻辑结构** ，存储 **相同数据类型** 的n个 **数据元素** 的 **有限序列**

- 线性表有两种**表示方法**：**顺序表示** 和 **链式表示**

- 用顺序表示的线性表叫 **顺序表**

- 用链式表示的线性表叫 **链表**

- 顺序表中用 **静态分配** 方式实现的叫 **静态顺序表**  
  用 **动态分配** 方式实现的叫 **动态顺序表**

- **链表** 又可以分为 **单链表（带头结点/不带头结点）** 、**双链表** 、**循环链表（循环单链表/循环双链表）**


## 顺序表

**优点**：可以 **随机访问** ，在 $O(1)$ 时间内找到指定元素；**存储密度高**  
**缺点**：**插入和删除要移动大量元素**；  **拓展容量不方便**

### 静态顺序表的实现

1. 首先定义顺序表的 **最大表容量**
   ```
    #define MAX_SIZE 100  // 定义静态顺序表的最大长度
   ```

2. 然后设置静态顺序表的 **结构体** ,包括 **数据域** 和 **表长变量**
    ```
    // 静态顺序表结构体
    struct StaticSeqList {
        int data[MAX_SIZE];  // 静态数组：用于存储顺序表的元素
        int length;  // 当前顺序表的长度（即元素个数）
    };
    ```

3. **初始化** 线性表
    1. 传入 **表名 &L**
    2. 初始化 **表长变量为0**
   ```
    // 初始化顺序表
    void InitList(StaticSeqList &L){
        L.length = 0; // 将顺序表的长度初始化为0，表示空表
    }
   ```

4. **判空操作**
    - 返回表长是否为 0
    ```
    // 判空
    bool Empty(StaticSeqList L) {
        return L.length == 0;  // 返回表长是否为 0
    }
    ```

5. **插入操作** ：在第i个位置（指位序）插入元素e
    1. 传入 **表名 &L** 、**位序 i** 、**元素 e**  
    <u>注意：对表有修改行为时，有变动的参数前面需要加上 **&**</u>
    2. 判断传入的位序是否合法。不能为0，最大可以插在最后一个元素的后面
    3. 判断表是否已满。就看当前表长有没有到最大表长
    4. 把当前表内第 i 个元素和它后面的元素都往后移一位，从最后一个元素开始移。把前面元素的值赋给后面元素
    5. 把 e 的值赋给第 i 个元素
    6. 表长增一
   ```
    // 在顺序表第i个元素插入元素e
    bool ListInsert(StaticSeqList &L, int i, int e) {
        // 判断插入位置是否合法，i是位序，在1 ~ length+1之间
        if(i < 1 || i > L.length +1)
            return false;
        // 判断表是否已满
        if(L.length >= MAX_SIZE)
            return false;
        
        // 将第i个元素及其后面的元素都后移一个位置（从最后一个元素开始移动）
        for(int j = L.length; j >= i; j--) {
            L.data[j] = L.data[j - 1];  // 把前一个位置的元素赋值给当前位置
        }
        L.data[i - 1] = e;  // 在位置为i-1（数组下标）除插入元素e
        L.length++;  // 表长增加1
        return true;
    }
   ```

6. **删除操作** ：删除表中第 i 个位置的元素，并用 e 返回
    1. 传入 **表名 &L** 、**位序 i**、 **元素 &e**
    2. 判断传入的位序是否合法。不能为0，也不能超过当前表长
    3. 用 e 保存被删除元素的值
    4. 把第 i 个元素后面的所有元素都往前移一位，从第一个元素开始移。把后面元素的值赋给前面元素的值
    5. 表长减一
   ```
    // 删除顺序表第i个位置的元素，并用e返回
    bool ListDelete(StaticSeqList &L, int i, int &e) {
        // 判断删除位置是否合法， i必须在1~length之间
        if(i < 1 || i > L.length)
            return false;

        // 保存被删除元素的值
        e = L.data[i - 1];

        // 将第i个元素之后的元素向前移一个位置（从第i个位置开始）
        for(int j = i; j < L.length; j++) {
            L.data[j - 1] = L.data[j];  // 将后一个位置的元素赋值给前一个位置
        }
        L.length--;  // 表长减1
        return true;
    }
   ```

7. **按值查找** ：查找表中第一个值为 e 的元素的位序，找不到返回 0
    1. 传入 **表名 L** 、**值 e** 
    2. 遍历表中的所有元素（从数组下标0开始）
    3. 如果当前元素值为 e ，则返回当前元素的位序（数组下标加1）
    4. 找不到返回0
   ```
    // 按值查找：返回顺序表中第一个值为e的元素的位序，找不到返回0
    int LacateElem(StaticSeqList L, int e) {
        for(int i = 0; i < L.length; i++) {
            if(L.data[i] == e)
                return i + 1;  // 返回位序
        }
        return 0;
    }
   ```

8. **按位查找** ：返回表中第 i 个位置的元素的值
    1. 传入 **表名 L** 、**位序 i**
    2. 判断输入是否合法
    3. 直接返回数组下标为 i - 1 的元素值
   ```
    // 按位查找：返回顺序表中第i个元素的值
    int GetElem(StaticSeqList L, int i) {
        // 判断输入是否合法
        if(i < 1 || i > L.length)
            return -1;
        
        return L.data[i - 1];  // 第i个元素存放在数组中的第i-1个位置
    }
   ```

9. **求表长**
    - 直接返回表长
    ```
    int Length(StaticSeqList L) {
        return L.length;
    }
    ```

10. **遍历打印顺序表** ：按顺序把表里的元素打印出来
    1. 传入 **表名 L**
    2. 遍历整个表
    3. 遍历时输出元素的值
    ```
    // 遍历打印顺序表
    void PrintList(StaticSeqList L) {
        for(int i = 0; i < L.length; i++) {
            std::cout << L.data[i] << " ";
        }
        std::cout << std::endl;
    }
    ```

11. **清空静态顺序表**
    - 只需把表长重置为空，数组中的数据会被覆盖不用理会。
    ```
    // 清空静态顺序表
    void ClearList(StaticSeqList & L) {
        L.length = 0;
    }
    ```


### 动态顺序表的实现

1. 首先设置动态顺序表的 **结构体** ，包括 **指针** 、**当前最大容量** 、**当前长度** 。指针指向这一片存储空间的开始地址。
    ```
    #include <cstdlib>  // 包含malloc和free函数

    // 动态顺序表结构
    struct DynamicSeqList {
        int *data;  // 指向动态分配数组的指针，指向这一片存储空间的存储地址
        int maxSize;  // 数组的最大容量
        int length;  // 当前长度
    };
    ```


2. **初始化** 顺序表
    1. 传入 **表名 &L** 、**初始分配大小 size**
    2. 申请 size 个大小为 int 的空间，并用 malloc 函数返回一个强制转换为特定类型的指向这片空间开始地址的指针
    3. 当前最大容量设为 size
    4. 当前长度设为 0
    ```
    // 初始化动态顺序表，size为初始分配的大小
    void InitList (DynamicSeqList &L, int size) {
        L.data = (int *)malloc(size * sizeof(int));  // 申请size个大小为int的空间，并用malloc函数返回一个强制转换为int类型的指向这片空间开始地址的指针
        if(!L.data)
            exit(1);  // 如果分配失败，则退出程序
        L.length = 0;  // 初始长度为0
        L.maxSize = size;  // 记录最大容量
    }
    ```

3. **判空**
    - 返回表长是否为 0
    ```
    // 判空
    bool Empty(DynamicSeqList L) {
        return L.length == 0;
    }
    ```

4. **扩容** ：增加容量
    1. 传入 **表名 &L** 、 **增加的长度 len**
    2. 新建一个指针，把原指针赋给他，用来保存
    3. 用 malloc 申请一个比原最大容量还大 len 个的空间
    4. 如果分配失败就退出程序
    5. 如果分配成功，就把原数组的元素复制到新数组
    6. 更新当前最大容量
    7. 用 free 方法释放原空间
    ```
    // 增加动态顺序表的容量（增加len个长度）
    void IncreaseSize(DynamicSeqList &L, int len) {
        int *p = L.data;  // 保存原数组指针
        // 申请新的更大的空间
        L.data = (int *)malloc((L.maxSize + len) * sizeof(int));
        if(!L.data)
            exit(1);  // 如果分配失败，则退出程序
        
        // 将原数组的元素复制到新数组
        for(int i = 0; i < L.length; i++) {
            L.data[i] = p[i];
        }
        L.maxSize += len;  // 更新最大容量
        free(p);  // 释放原空间
    }
    ```

5. **插入** ：在第 i 个位置插入元素 e。（与静态顺序表相同）
    ```
    // 在顺序表第i个位置插入元素e
    bool ListInsert(DynamicSeqList &L, int i, int e) {
        // 判断插入位置是否合法，i必须在1~length+1之间
        if(i < 1 || i > L.length + 1) 
            return false;
        // 判断表是否已满，若已满则增加表容量
        if(L.length >= L.maxSize)
            IncreaseSize(L, 10);

        // 将第i个元素及其后面的元素往后移一个位置（从最后一个元素开始）
        for(int j = L.length; j >= i; j--) {
            L.data[j] = L.data[j - 1];  // 将前一个位置的元素赋值给当前位置
        }
        L.data[i -1] = e;  // 当位置i-1出插入元素e
        L.length++;  // 表长加1
        return true;
    }
    ```

6. **删除** ：删除第 i 个元素，并用 e 返回（与静态顺序表相同）
    ```
    // 删除表中第i个元素，并用e返回
    bool ListDelete(DynamicSeqList &L, int i, int &e) {
        // 判断删除位置是否合法，i必须要在1~length之间
        if(i < 1 || i > L.length)
            return false;
        e = L.data[i -1];  // 保存被删除元素的值

        // 将第i个元素之后的所有元素前移一位（从第一个元素开始）
        for(int j = i; j < L.length; j++) {
            L.data[j - 1] = L.data[j];  // 将后一个位置的元素赋值给前一个元素
        }
        L.length--;  // 表长减1
        return true;
    }
    ```

7. **按值查找** ：查找表中第一个值为 e 的元素的位序，找不到返回 0（与静态顺序表相同）
    ```
    // 按值查找：找到第一个值为e的元素的位序，找不到返回0
    int LocateElem(DynamicSeqList L, int e) {
        for(int i = 0; i < L.length; i++) {
            if(L.data[i] == e)
                return i + 1;  // 返回位序
        }
        return 0;  // 未找到
    }
    ```

8. **按位查找** ：返回表中第 i 个位置的元素的值（与静态顺序表相同）
    ```
    // 按位查找：返回列表中第i个元素的值
    int GetElem(DynamicSeqList L, int i) {
        return L.data[i -1];
    }
    ```

9. **求表长**
    - 返回表长
    ```
    // 求表长
    int Length(DynamicSeqList L) {
        return L.length;
    }
    ```

10. **遍历打印顺序表** （与静态顺序表相同）
    ```
    // 遍历打印顺序表
    void PrintList(DynamicSeqList L) {
        for(int i = 0; i < L.length; i++){
            std::cout << L.data[i] << " ";
        }
        std::cout << std::endl;
    }
    ```

11. **销毁操作**
    - 先释放数据域空间
    - 再把指针指向空
    - 最后把表长和最大表容量置为 0
    ```
    // 销毁操作
    void DestroyList(DynamicSeqList &L) {
        free(L.data);
        L.data = nullptr;
        L.length = 0;
        L.maxSize = 0;
    }
    ```


## 链表

### 单链表

#### 带头结点的单链表的实现

1. 首先定义单链表的 **结点结构**。
    - 包括一个 **数据域 data** 和一个结点类型 **指针域 *next**。这个指针指向的是下一个结点的空间地址
    ```
    // 单链表节点结构
    struct LNode {
        int data;  // 数据域
        LNode *next;  // LNode类型的指针域，指向下一个节点
    };
    ```

2. **初始化** 带头结点的单链表
    1. 传入 **头指针 \*&L** 的值。
         - 因为初始化要创建一个头结点，也就是说头指针 L 的值从 nullptr 指向了新创建的头结点，所以修改了 L 的值那就要加返回符 *&*。  
        - <u>头指针同时也是一个单链表的标识</u>
    2. 创建一个 **头结点 L**。
    3. 把头结点 L 的 **next 指向 nullptr**
    ```
    // 初始化单链表
    void InitList(LNode *&L) {
        L = new LNode;  // 创建一个头结点
        L -> next = nullptr;  // 头结点的next设为空
    }
    ```

3. **头插法** 插入新结点 e ：把新元素都插到头结点的后一个位置上
    1. 传入 **头指针 \*L** 、**新结点 e** 。
        - 因为是带头结点的单链表，所以头指针的值不会变，始终指向头结点，因此不用带返回符 &
    2. 新建一个结点 s
    3. 把 e 的值赋给 s 的数据域
    4. 把 s 的 next 指向头结点 L 的 next 域
    5. 头结点 L 的 next 指向 s
    ```
    // 头插法插入元素（在头结点之后插入）
    void HeadInsert(LNode *L, int e) {
        LNode *s = new LNode;  // 新建一个结点
        s -> data = e;  // 把 e 赋值给s的数据域
        s -> next = L -> next;  // 把新结点的next指向头结点的next
        L -> next = s;  // 把头结点的next指向s
    }
    ```

4. **尾插法** 插入新结点 e ：把新结点插到链表的末尾
    1. 传入 **头指针 \*L** 、**新结点 e**
    2. 新建一个结点 s 
    3. 把 e 的值赋给 s 的数据域
    4. 把 s 的 next 指向 nullptr
    5. 新建一个指针 *p ，并让他指向头结点 L
    6. 找到尾结点
        - 遍历整个链表，直到 p 的 next 为 nullptr ，表示当前结点为尾结点
    7. 把尾结点 p 的 next 指向 s
    ```
    // 尾插法插入元素（在链表尾部插入）
    void TailInsert(LNode *L, int e) {
        LNode *s = new LNode;  // 新建一个结点
        s -> data = e;  // 把 e 赋给s的数据域
        s -> next = nullptr;  // 把新结点的next指向空

        LNode *p = L;  // 新建一个指针P，指向头结点
        while(p -> next) {
            p = p -> next;  // 从头结点开始循环整个链表，直到找到当前链表内next指向空的尾结点
        }
        p -> next = s;  // 把s结点放到链表尾部
    }
    ```

5. **按位删除** （删除第 i 个位置的结点，并用 e 返回）
    1. 传入 **头指针 \*L** 、**位置 i** 、**返回值 &e**
    2. 判断输入是否合法。 i 的值不能为 0
    3. 新建一个指针 *p ，让它指向头结点 L
    4. 设置一个计数器 j , 表示当前指向第几个结点。默认设为 0（头结点表示为 0 ）
    5. 找到被删除结点的前一个结点
        - 遍历整个链表，直到 j = i-1，表示当前结点为被删除结点的前一个结点
        - 如果遍历时 指针 p 的 next 指向了 nullptr 即指向了最后一个元素，则说明输入的位置超过了表长
    6. 再新建一个指针 *q ,让它指向被删除的结点 p -> next
    7. 用 e 记录被删除结点 p 的数据域的值
    8. 把被删除结点的前一个结点 p 的 next 指向 被删除结点 q 的下一个结点
    9. 释放被删除结点 p 的空间
    ```
    // 按位删除（删除第i个结点，并返回其值）
    bool ListDelete(LNode *L, int i, int &e) {
        if(i < 1)
            return false;  // 判断输入是否合法，删除位置不能为0，是否超过表长+1在后面判断

        // 首先要找到被删除结点的前一个结点
        LNode *p = L;  // 新建一个指针P，指向头结点
        int j = 0;  // 设置一个计数器，记录当前是第几个结点
        while(p -> next && j < i - 1) {
            p = L  -> next;  // 循环查找，直到找到第i-1个结点
            j++;  // 计数器加一
        }
        if(!p -> next)
            false;  // 若p的next指向空，则说明i超出表长+1
            
        LNode *q = p -> next;  // 新建一个指针q，指向被删除的结点
        e = q -> data;  // 用e记录被删除结点的值
        p -> next = q -> next;  // 把被删除结点的前一个结点的next指向被删除结点的下一个结点
        delete q;  // 释放被删除结点的空间
        return true;
    }
    ```

6. **交换位置** （把第 i 个结点和前驱结点交换）
    1. 传入 **头指针 \*L** 、**交换的结点 i**
    2. 找到第 i 个结点的 **前驱结点的前驱结点**
        - 新建一个指针 **\*w** ，指向头结点
        - 设置一个 **计数器 j** ，记录当前指向第几个结点，默认为 0 ，指向头结点
        - 找到第 i - 2 个结点
            - 遍历整个链表，直到找到第 i - 2 个结点
            - 如果当前遍历的结点的 next 的 next 为空，则说明没有第 i 个结点
    3. 新建一个指针 **\*q** ，指向第 i - 1 个结点
    4. 新建一个指针 **\*p** ，指向第 i 个结点
    5. 新建一个指针 **\*e** ，指向第 i + 1 个结点
    6. 把第 i - 2 个结点指向第 i 个结点
    7. 把第 i 个结点的 next 指向第 i - 1 个结点
    8. 把第 i - 1 个结点的 next 指向第 i + 1 个结点
    ```
    // 交换位置（把第 i 个结点和前驱结点交换）
    bool Transform(LNode *L, int i) {
        if(i < 1) 
            return false;  // 判断输入是否合法

        // 首先找到第 i 个结点的前驱结点的前驱结点
        LNode *w = L;  // 新建一个指针，指向头结点
        int j = 0;  // 设置一个计数器，记录当前指向第几个结点，默认为0， 指向头结点
        while(w -> next && j < i - 2) {
            w = w -> next;
            j++;
        }
        if(!w -> next -> next) {
            return false;
        }
        
        LNode *q = w -> next;  // 新建一个指针 q ，指向第 i-1 个结点
        LNode *p = q -> next;  // 新建一个指针 p ，指向第 i 个结点
        LNode *e = p -> next;  // 新建一个指针 e ，指向第 i+1 个结点

        w -> next = p;  // 先把第 i-2 个结点的next 指向第 i 个结点
        p -> next = q;  // 把第 i 个结点的 next 指向第 i 个结点的前驱结点
        q -> next = e; // 最后把第 i-1 个结点的next指向 第i+1个结点

        return true;
    }
    ```

7. **遍历打印单链表**
    1. 传入 **头指针 \*L**
    2. 新建一个指针 *p ，并让它指向头结点的下一个结点
    3. 遍历整个单链表，同时打印当前结点的数据域，直到指针指向 nullptr
    ```
    // 遍历打印链表
    void PrintList(LNode *L) {
        LNode *p = L ->next;  // 新建一个指针p， 指向头结点后的第一个结点
        while(p) {
            std::cout << p -> data << " ";  // 打印出当前结点的数据域
            p = p -> next;  // 打印完p指针指向下一个结点
        }
        std::cout << std::endl;  // 换行
    }
    ```


#### 不带头结点的单链表的实现

1. 首先定义单链表的 **结点结构**
    - 包括一个 **数据域 data** 和一个 **指针域 *next***，这个指针指向的是下一个结点的空间地址
    ```
    // 不带头结点的单链表结点结构
    struct LNode {
        int data;  // 数据域
        LNode *next;  // 指针域
    };
    ```

2. **初始化** 单链表
    1. 传入 **头指针 \*&L**
    2. 让头指针 L 指向 nullptr
    ```
    // 初始化单链表
    void InitList(LNode *&L) {
        L = nullptr;  // 因为不带头结点，就将头指针指向空
    }
    ```

3. **插入** （在第 i 个位置插入 e ）
    1. 传入 **头指针 \*&L** ， **插入位置 i**， **返回值 e**
    2. 判断输入是否合法，位置 i 不能小于 1
    3. 如果是在表头位置插入
        1. 新建一个结点 s
        2. 把 e 的值赋给 s 的数据域
        3. 让 s 的 next 指向当前的第一个结点 L
        4. 让头指针 L 指向 s
    4. 如果不是插在表头位置
        1. 新建一个结点 s
        2. 把 e 的值赋给 s 的数据域
        3. 找到第 i-1 个结点
            - 创建一个指针 *p ,指向头结点
            - 设置一个计数器，记录当前指向第几个结点，初始设为 1 （没有头结点）
            - 遍历这个链表，直到 j = i-1 ，表示找到了第 i-1 个结点
            - 如果指针 p 指向 nullptr ，则说明插入位置超过了 表长+1
        4. 把 s 的 next 指向 p 的 next 即指向第 i 个位置的结点
        5. 让 p 的 next 指向 s ，即把 p 和 s 连起来
    ```
    // 插入操作，在第i个位置插入e
    bool ListInsert(LNode *&L, int i, int e) {
        if(i < 1) {
            false;  // 判断输入是否合法，位置不能小于1
        }
        else if(i == 1) {  // 若在第一个位置插入
            LNode *s = new LNode;  // 创建一个新结点s
            s -> data = e;  // 把e的值赋给s的数据域
            s -> next = L;  // 把新建的s结点的next指向当前第一个结点L
            L = s;  // 把头指针指向s
        }
        else {
            LNode *p = L;  // 新建一个指针p，指向当前第一个结点
            int j = 1;  // 用来记录当前指向第几个结点，默认当前指向一号
            while(p && j < i - 1) {  // 找到插入位置的前一个结点
                p = p -> next;
                j++;
            }
            if(!p)
                return false;  // 插入位置前一个结点为空，说明此位置超过了表长+1

            LNode *s = new LNode;  // 新建一个结点s
            s -> data = e;  // 把e赋给s的数据域
            s -> next = p -> next;  // 让s的next指向被插入位置上的结点
            p -> next = s;  // 把插入位置前一个结点和新结点连接起来
        }
        return true;
    }
    ```

4. **删除** （删除第 i 个位置的结点，并用 e 返回）
    1. 传入 **头指针 \*&L** ，**删除位置 i** ， **返回值 &e**
    2. 判断删除位置是否合法， i 不能小于 1
    3. 如果删除第一个结点
        1. 新建一个指针 *p ，指向第一个结点 L
        2. 用 e 保存头结点的值
        3. 让头指针 L 指向第二个结点 L -> next
        4. 释放 p 指针的空间
    4. 如果删除的是其他结点，那就找到被删除结点的前一个结点
        1. 新建一个指针 *p ,指向第一个结点
        2. 设置一个计数器， 表示当前指向第几个结点，默认设为 1 （没有头结点）
        3. 遍历整个链表，直到找到第 i-1 个结点
            - 如果 p -> next 等于 nullptr ，那就表示传入的位置超出了表长
        4. 新建一个指针 *q ,指向被删除的结点 p -> next
        5. 用 e 返回被删除结点的值 q -> data
        6. 把被删除结点的前一个结点的 next 指向被删除结点 q 的 next
        7. 释放被删除结点的空间 q
    ```
    // 删除操作（删除第i个结点，并返回其值
    bool ListDelete(LNode *&L, int i, int &e) {
        if(i < 1) {
            return false;  // 删除位置不能小于1
        }
        // 若删除第一个结点
        else if(i == 1) {
            LNode *p = L;  // 新建一个指针p，指向当前表中第一个结点
            e = p -> data;  // 用e返回被删除结点的值
            L = L -> next;  // 把头指针指向第二个结点
            delete p;  // 删除第一个结点
        }
        else{
            // 找到被删除结点的前一个结点
            LNode *p = L;  // 新建一个指针p，指向当前第一个结点
            int j = 1;  // 记录当前是第几个结点，默认指向第一个
            while(p -> next && j < i - 1) {
                p = p -> next;
                j++;
            }
            if(!p -> next) 
                return false;  // 说明第i个位置没有结点，超出了表长
        
            LNode *q = p -> next;  // 新建一个指针q，指向被删除的结点
            e = q -> data;  // 用e返回被删除结点的值
            p -> next = q -> next;  // 把第i-1个结点的next指向被删除结点的下一个结点
            delete q;  // 释放被删除结点的空间
        }
        return true;
    }
    ```

5. **遍历打印单链表**
    1. 传入 **头指针 \*L**
    2. 新建一个指针 *p ，指向第一个节点 L
    3. 遍历整个链表，同时输出当前结点的值，直到 p 为空
    ```
    // 遍历打印单链表
    void PrintList(LNode *L) {
        LNode *p = L;  // 新建一个指针p，指向表中第一个结点
        while(p) {
            std::cout << p -> data << " ";  // 打印当前结点的值
            p = p -> next;
        }
        std::cout << std::endl;    
    }
    ```


### 双链表的实现

1. 首先定义双链表的 *结点结构* 。包括一个 *数据域* 、*指向前驱的指针* 、*指向后继的指针*

2. *初始化*
    1. 创建一个头结点 L
    1. 传入 *头指针 \*&L* ，让头指针指向头结点
    2. 把前驱指针 prior 指向 nullptr (头结点的前驱指针 prior 永远指向空)，把后继指针 next 指向空，因为当前没有其他结点

3. *插入* （在第 i 个位置插入结点 e ）
    1. 传入 *头指针 L* 、*插入位置 i* 、*插入的值 e*
    2. 判断插入位置是否合法，i 不能为0
    3. 找到插入位置的前一个结点
        1. 新建一个指针 p，指向头结点
        2. 设置一个计数器，记录当前指向第几个结点，默认设为 0 （头结点记为 0 ）
        3. 遍历整个链表，直到 j = i-1
        4. 如果 p 指向空，即插入位置的前一个结点为空，就说明插入位置超过了表长
    4. 新建一个结点 s
    5. 把 e 的值赋给 s 的数据域
    6. 让新结点 s 的 next 指向 p 的 next
    7. 如果 p 结点后面还有结点，那么就把 p 后面的结点的 prior 指向 s
    8. 把 s 的 prior 指向 p 结点
    9. 把 p 结点的 next 指向 s

4. *删除* （删除第 i 个位置的结点，并用 e 返回）
    1. 传入 *头指针 L* 、*删除位置 i* 、*返回值 e*
    2. 判断删除位置是否合法，i 不能为 0
    3. 找第 i 个位置的结点
        1. 新建一个指针 p ，让它指向头结点之后的第一个结点
        2. 设置一个计数器，记录当前指向第几个结点。默认为 1（指向头结点之后的第一个结点）
        3. 遍历整个链表，直到 j = i
        4. 如果遍历过程中 p 指向空，则说明第 i 个位置没有结点，输入的位置 i 不合法
    4. 直到第 i 个结点后，用 e 返回 p 的值
    5. 再把结点 p 的前一个结点的 next 指向 p 的后一个结点
    6. 如果 p 结点后还有结点，就把后面的这个结点的 prior 指向 p 的前一个结点
    7. 释放被删除结点 p 的空间


### 循环链表

#### 循环单链表的实现
1. 首先定义循环单链表的 *结点结构* ，包括一个 *数据域* 和一个 *指针域*

2. *初始化*
    1. 传入 *头结点 \*&L*
    2. 创建一个头结点
    2. 让头结点的 next 指向自己，形成循环

3. *插入* （在 L 的第 i 个位置插入结点 e ）
    1. 传入 *头结点 \*L* 、*插入位置 i * 、*插入结点 e*
    2. 判断插入位置是否合法，插入位置不可以为 0
    3. 找到删除位置的前一个结点
        1. 新建一个指针 p ，指向头结点，用于遍历整个链表
        2. 设置一个计数器，记录当前指向的是第几个结点，初始设为 0，表示当前指向的是头结点
        3. 遍历整个链表，直到找到第 i-1 个结点，遍历结束的标志为当前结点为尾结点。
            - 尾结点的标志为 next 指向了头结点
        4. 如果遍历完整个链表后 j 不等于 i ，就说明插入位置前没有结点，即插入位置超过了表长加一
    4. 新建一个结点 s
    5. 把 e 的值赋给 s
    6. 把 s 的 next 指向第 i 个位置的结点
    7. 把插入位置前面一个的结点 p 的 next 指向 s

4. *删除* （删除 L 的第 i 个结点，并用 e 返回）
    1. 传入 *头指针 \*L* 、*删除位置 i* 、*返回值 &e*
    2. 判断输入是否合法，删除位置 i 不能为 0
    3. 找到第 i - 1 个结点
        1. 新建一个指针 p ，指向头结点
        2. 设置一个计数器，记录当前指向第几个结点，默认为 0 （头结点记为 0 ）
        3. 遍历整个链表，找到第 i - 1 个结点
        4. 遍历完整个链表后没有找到第 i - 1 个结点，或者第 i - 1 个结点是尾结点，则说明删除位置超过了表长
        5. 新建一个指针 q ，指向被删除的结点
        6. 用 e 返回被删除结点的值
        7. 把第 i - 1 个结点的 next 指向被删除结点的后一个结点
        8. 释放被删除结点的空间

5. *遍历打印*
    1. 传入 *头指针 \*L*
    2. 新建一个指针 p ,指向头节点
    3. 遍历整个链表，同时打印每个结点的值


#### 循环双链表的实现

1. 首先定义循环双链表的 *结点结构* ，包括 *数据域* ，*指向前驱结点的指针 prior* ，*指向后继结点的指针 next*

2. *初始化*
    1. 传入 *头指针 \*&L*
    2. 创建一个头结点 L
    3. 把头结点的 prior 和 next 都指向自己

3. *插入* （在 L 的第 i 个位置插入结点 e）
    1. 传入 *头结点 \*L* 、*插入位置 i* 、*插入结点 e*
    2. 判断插入位置是否合法， i 不能为 0
    3. 找到插入位置的前一个结点
        1. 新建一个指针 p ，指向头结点
        2. 设置一个计数器，记录当前指向第几个结点，
        3. 遍历整个链表，找到第 i - 1 个结点
        4. 如果遍历完没有找到第 i - 1 个结点，那就说明插入位置超过了 表长+1
    4. 新建一个结点 s 
    5. 把 e 的值赋给 s
    6. 把 s 的 next 指向 p 的下一个结点，也就是第 i 个结点
    7. 把 s 的 prior 指向 p
    8. 把第 i 个结点的 prior 指向新结点
    9. 把第 i 个结点 p 的 next 指向新结点

4. *删除* （删除 L 的第 i 个结点，并用 e 返回）
    1. 传入 *头指针 \*L* 、*删除位置 i* 、*返回值 \*e*
    2. 判断删除位置是否合法，i 不能为 0
    3. 找到第被删除结点的位置
        1. 新建一个指针 p ，指向头结点
        2. 设置一个计数器，记录当前指向第几个结点，默认为 0（头结点记为 0）
        3. 遍历整个链表，直到找到被删除结点
        4. 如果遍历完链表，没有找到被删除结点，就说明删除位置超过了表长
    4. 把被删除结点的值赋给 e 
    5. 把被删除结点的前一个结点的 next 指向被删除结点的下一个结点
    6. 把被删除结点的下一个结点的 prior 指向被删除结点的前一个结点
    7. 是否被删除结点 p 的空间

5. *遍历打印循环双链表*
    1. 传入 *头结点 \*L*
    2. 新建一个指针 p ，指向头结点
    3. 遍历整个链表，同时输出结点的值