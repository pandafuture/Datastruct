# 队列

- **队列** 是只允许在一端进行插入，在另一端删除的线性表。

- **队头（队首）** ：允许删除的一端

- **队尾** ：允许插入的一端

- **空队列** ：空表

- **队列的特点** ：**先进先出（FIFO）**

- **队列的基本操作**
  - **初始化队列**
  - **判队列空**
  - **入队**
  - **出队**
  - **读队首元素**
  - **销毁队列**

- 队列有两种存储方式：**顺序存储** 和 **链式存储**

- 采用顺序存储的队列称为 **顺序队列**

- 采用链式存储的队列称为 **链式队列**

- 把顺序队列从逻辑上是为一个环称为 **循环队列**





# 顺序队列（循环队列）的实现
1. 定义队列的 **最大容量**
    ```
    #define MAX_SIZE 50  // 定义队列的最大容量
    ```

2. 定义顺序队列（循环队列） **存储结构** 。包括存储队列元素的 **数组** 、指向队首元素的 **队首“指针” front** 、指向队尾元素的下一个位置的 **队尾“指针” rear**
    ```
    // 顺序队列（循环队列）存储结构
    struct SeqQueue {
        int data[MAX_SIZE];  // 存储队列元素的数组
        int front;  // 队首指针，指向队首元素
        int rear;  // 队尾指针，指向队尾元素的下一个位置
    };
    ```

3. **初始化队列**
   1. 传入 **队列名 &Q**
   2. 初始化队首“指针”为0
   3. 初始化队尾“指针”为0
    ```
    // 初始化队列
    void InitQueue(SeqQueue &Q) {
        Q.front = 0;  // 初始化队首指针为 0
        Q.rear = 0;  // 初始化队尾指针为 0
    }
    ```

4. **判空操作**
   1. 传入 **队列名 Q**
   2. 看队首“指针”是否与队尾“指针”相等。如果相等，则队列为空；如果不相等，则队列不为空
    ```
    // 判空操作
    bool Empty(SeqQueue Q) {
        return Q.front == Q.rear;
    }
    ```

5. **判满操作**
   1. 传入 **队列名 Q**
   2. 看队尾“指针”加一取模最大容量后是否等于队首“指针”，如果等于，则队列已满；如果不等于，则队列未满
    ```
    // 判满操作
    bool Full(SeqQueue Q) {
        return (Q.rear + 1) % MAX_SIZE == Q.front;  // 队尾下一个位置是队头时队列满
    }
    ```

6. **入队操作**
   1. 传入 **队列名 &Q** 、**入队元素 e**
   2. 先判断队列是否已满
   3. 把 e 入队到队尾指针指向的位置
   4. 把队尾指针加一取模最大容量
    ```
    // 入队操作
    bool EnQueue(SeqQueue &Q, int e) {
        // 先判断队列是否已满
        if(Full(Q)) {
            std::cout << "队列已满" << std::endl;
            return false;
        }

        Q.data[Q.rear] = e;  // 把 e 入队到队尾指针指向的位置
        Q.rear = (Q.rear + 1) % MAX_SIZE;  // 队尾指针加一取模
        return true;
    }
    ```

7. **出队操作**
   1. 传入 **队列名 &Q** 、**返回值 &e**
   2. 先判断队列是否为空
   3. 返回队首元素值
   4. 把队首指针后移一位
    ```
    // 出队操作
    bool DeQueue(SeqQueue &Q, int &e) {
        // 先判断队列是否为空
        if(Empty(Q)) {
            std::cout << "队列为空" << std::endl;
            return false;
        }

        e = Q.data[Q.front];  // 获取队首元素
        Q.front = (Q.front + 1) % MAX_SIZE;  // 队首指针后移一位
        return true;
    }
    ```

8. **读队首元素**
   1. 传入 **队列名 Q** 、**返回值 &e**
   2. 先判断队列是否为空
   3. 获取队首元素
    ```
    // 读队首元素
    bool GetHead(SeqQueue Q, int &e) {
        // 先判断队列是否为空
        if(Empty(Q)) {
            std::cout << "队列为空" << std::endl;
            return false;
        }

        e = Q.data[Q.front];  // 获取队首元素
        return true;
    }
    ```

9. **获取队列长度**
   1.  传入 **队列名 Q**
   2.  直接返回队尾指针值与队首指针值的插值加上最大容量后取模最大容量的结果
    ```
    // 获取队列长度
    int Length(SeqQueue Q) {
        return (Q.rear - Q.front + MAX_SIZE) % MAX_SIZE;
    }
    ```

10. **输出队列**
    1.  传入 **队列名 Q**
    2.  先判断队列是否为空
    3.  遍历整个循环队列，同时打印每个元素
    ```
    // 输出队列
    void PrintQueue(SeqQueue Q) {
        // 先判断队列是否为空
        if(Empty(Q)) {
            std::cout << "队列为空" << std::endl;
            return;
        }

        // 遍历整个循环队列，同时打印每个元素
        int i = Q.front;  // 从队首开始
        while(i != Q.rear) {
            std::cout << Q.data[i] << " ";
            i = (i + 1) % MAX_SIZE;
        }
        std::cout << std::endl;
    }
    ```

11. **销毁队列**
    1.  传入 **队列名 &Q**
    2.  对于静态数组，不需要释放内存，只需要重置队首指针和队尾指针
    ```
    // 销毁队列
    void DestroyQueue(SeqQueue &Q) {
        // 对于静态数组，不需要释放内存
        Q.front = 0;  // 重置队首指针
        Q.rear = 0;  // 重置队尾指针
    }
    ```





# 链式队列的实现
## 链式队列（不带头结点）的实现
1. 先定义链式队列（不带头结点）的 **结点结构** 。包括一个存储结点数据的 **数据域 data** 和一个指向下一个结点的 **指针域 \*next**
    ```
    // 链式队列（不带头结点）结点结构
    struct QueueNode {
        int data;  // 数据域
        QueueNode *next;  // 指针域
    };
    ```

2. 定义链式队列（不带头结点）的 **队列结构** 。包括 **队头指针 \*front** 和 **队尾指针 \*rear** 和 **队列长度 size**
    ```
    // 链式队列（不带头结点）结构
    struct LinkQueue {
        QueueNode *front;  // 队头指针，指向第一个元素
        QueueNode *rear;  // 队尾指针，指向最后一个元素
        int size;  // 队列中元素个数
    };
    ```

3. **初始化**
   1. 传入 **队列名 &Q**
   2. 设置 **队头指针** 和 **队尾指针** 指向空
   3. 元素个数初始化为 0
    ```
    // 初始化
    void InitQueue(LinkQueue &Q) {
        Q.front = nullptr;  // 队头指针置为空
        Q.rear = nullptr;  // 队尾指针置为空
        Q.size = 0;  // 元素个数初始化为 0
    }
    ```

4. **判队空**
   1. 传入 **队列名 Q**
   2. 直接看队头指针是否指向空，若指向空，则队列为空，若不指向空，则队列不为空
    ```
    // 判队空
    bool IsEmpty(LinkQueue Q) {
        return Q.front == nullptr;  // 队头为空表示队列空
    }
    ```

5. **入队**
   1. 传入 **队列名 &Q** 、**要入队的元素 e**
   2. 创建一个新结点 s
   3. 把 e 的值赋给新结点 s
   4. 把新结点 s 的 next 指向空，因为新结点需要插入到队尾
   5. 判断队列是否为空
   6. 如果为空，那么新结点既是队头结点也是队尾结点。就把队头指针和队尾指针都指向新结点
   7. 如果不为空，就把新结点链接到队尾，然后更新队尾指针
   8. 更新队列大小
    ```
    // 入队
    void EnQueue(LinkQueue &Q, int e) {
        // 创建新结点
        QueueNode *s = new QueueNode;
        s -> data = e;  // 把 e 的值赋给新结点 s
        s -> next  = nullptr;  // 新结点 s 在队尾插入，就把 next 值为空

        // 先判断队列是否为空
        if(IsEmpty(Q)) {
            // 队列为空时，新结点既是队头也是队尾
            Q.front = s;  // 把队头指针指向新结点
            Q.rear = s;  // 把队尾指针指向新结点
        }
        else {
            // 队列非空时，把新结点链接到队尾
            Q.rear -> next = s;
            Q.rear = s;  // 更新队尾指针
        }

        Q.size++;  // 更新队列大小
    }
    ```

6. **出队**
   1. 传入 **队列名 &Q** 、**返回值 e**
   2. 先判断队列是否为空
   3. 新建一个指针 p ，指向队首元素
   4. 用 e 返回队首元素的值
   5. 更新队首指针指向第二个元素
   6. 如果队列中只有一个元素，那么队首元素出队后，队列为空，就把队尾指针也指向空
   7. 删除 p 结点
   8. 更新队列大小减一
    ```
    // 出队
    bool DeQueue(LinkQueue &Q, int &e) {
        // 先判断队列是否为空
        if(IsEmpty(Q)) {
            std::cout << "队列为空" << std::endl;
            return false;
        }

        QueueNode *p = Q.front;  // 新建一个指针 p ，指向队首
        e = p -> data;  // 用 e 返回队首元素的值
        Q.front = Q.front -> next;  // 更新队首指针
        // 如果队列只有一个元素，出队后队列为空，就更新队尾指针
        if(Q.front == nullptr) {
            Q.rear = nullptr;
        }

        // 删除 p 结点
        delete p;

        // 更新队列大小
        Q.size--;

        return true;
    }
    ```

7. **读队首元素**
   1. 传入 **队列名 Q** 、**返回值 e**
   2. 先判断队列是否为空
   3. 用 e 返回队首元素的值
    ```
    // 读队首元素
    bool GetFront(LinkQueue Q, int &e) {
        // 先判断队列是否为空
        if(IsEmpty(Q)) {
            std::cout << "队列为空" << std::endl;
            return false;
        }

        e = Q.front -> data;  // 用 e 返回队首元素的值
        return true;
    }
    ```

8. **获取队列长度**
   1. 传入 **队列名 Q**
   2. 直接返回队列长度值
    ```
    // 获取队列长度
    int QueueLength(LinkQueue Q) {
        return Q.size;  // 直接返回队列长度
    }
    ```

9. **打印队列内容**
   1.  先判断队列是否为空
   2.  新建一个指针 p ，指向队首元素
   3.  遍历整个队列，同时输出每个元素的值
    ```
    // 打印队列内容
    void PrintQueue(LinkQueue Q) {
        // 先判断队列是否为空
        if(IsEmpty(Q)) {
            std::cout << "队列为空" << std::endl;
            return;
        }

        QueueNode *p = Q.front;  // 新建一个指针 p ，指向队首
        // 遍历整个队列，同时输出每个元素
        while(p != nullptr) {
            std::cout << p -> data << " ";
            p = p -> next;
        }
        std::cout << std::endl;
    }
    ```

10. **销毁队列**
    1.  传入 **队列名 &Q**
    2.  设置一个返回值 e
    3.  循环出队所有元素，直到队列为空
    ```
    // 销毁队列
    void DestroyQueue(LinkQueue &Q) {
        int e;  // 作为返回值
        // 循环出队所有元素
        while(!IsEmpty(Q)) {
            DeQueue(Q, e);
        }
    }
    ```