# 栈

- **栈** 是只允许在一端插入或者删除的线性表。

- **栈顶** ：允许插入和删除的一端

- **栈底** ：不允许插入和删除的一端

- **空栈** ：空表

- **栈的特点** ：**后进先出（FIFO）**

- **栈的基本操作**
  - **初始化**
  - **销毁**
  - **进栈**
  - **出栈**
  - **读栈顶元素**
  - **判空**

- **栈的数学性质** ：n 个不同元素入栈时，出栈元素不同排列的个数为 **${1\over{n+1}}C^n_{2n}$** （卡特兰数）

- 栈有两种存储方式：**顺序存储结构** 和 **链式存储结构**

- 采用顺序存储的栈称为 **顺序栈**

- 采用链式存储的栈称为 **链表**

- 顺序栈中还包括了 **共享栈**





# 顺序栈的实现
1. 首先定义 **栈的最大容量**
    ```
    #define MAX_SIZE 100  // 定义栈的最大容量
    ```

2. 定义 **顺序栈结构体**
   - 包括 **存放栈中元素的数组** 和 记录栈顶元素的数组下标的 **栈顶“指针”**
    ```
    // 顺序栈结构体
    struct SequenceStack {
        int data[MAX_SIZE];  // 存储栈元素的数组
        int top;  // 栈顶“指针” ，指向栈顶元素的数组下标
    };
    ```

3. **初始化**
   1. 传入 **栈名 &S**
   2. 把 **栈顶“指针”** 初始化为 **-1** ，表示空栈
    ```
    // 初始化
    void InitStack(SequenceStack &S) {
        S.top = -1;  // 栈顶“指针”初始化为 -1 ，表示空栈
    }
    ```

4. **判空**
   1. 传入 **栈名 S**
   2. 直接返回栈顶指针是否指向 -1
    ```
    // 判空
    bool Empty(SequenceStack S) {
        return S.top == -1;  // 直接返回栈顶“指针”是否为 -1
    }
    ```

5. **判满**
   1. 传入 **栈名 S**
   2. 直接返回栈顶指针是否为最大容量减一，若是，则栈满；若不是，则栈未满。
    ```
    // 判满
    bool Full(SequenceStack S) {
        return S.top == MAX_SIZE - 1;  // 直接返回栈顶“指针”是否为最大表长 - 1
    }
    ```

6. **入栈操作**
   1. 传入 **栈名 &S** 、**要入栈的元素 e**
   2. 先判断栈是否已满
   3. 先把栈顶“指针”加一后，再把元素 e 入栈
    ```
    // 入栈操作
    bool Push(SequenceStack &S, int e) {
        // 先判断栈是否已满
        if(Full(S)) {
            std::cout << "栈已满" << std::endl;
            return false;
        }

        S.data[++S.top] = e;  // 栈顶“指针”先加一，然后入栈
        return true;
    }
    ```

7. **出栈操作**
   1. 传入 **栈名 S** 、**返回值 &e**
   2. 先判断栈是否为空
   3. 然后读取栈顶元素的值，再把栈顶“指针”减一
    ```
    // 出栈操作
    bool Pop(SequenceStack &S, int &e) {
        // 先判断栈是否为空
        if(Empty(S)) {
            std::cout << "栈为空" << std::endl;
            return false;
        }

        e = S.data[S.top--];  // 读取出栈顶元素的值，然后指针减一
        return true;
    }
    ```

8. **读栈顶元素**
   1. 传入 **栈名 S** 、**返回值 &e**
   2. 先判断栈是否为空
   3. 获取栈顶元素的值
    ```
    // 读栈顶元素
    bool GetTop(SequenceStack S, int &e) {
        // 先判断栈是否为空
        if(Empty(S)) {
            std::cout << "栈为空" << std::endl;
            return false;
        }

        e = S.data[S.top];  // 获取栈顶元素的值
        return true;
    }
    ```

9. **输出栈**
   1.  传入 **栈名 S**
   2.  先判断栈是否为空
   3.  再从栈顶开始遍历整个栈，同时打印每个元素的值
    ```
    // 打印栈
    void PrintStack(SequenceStack S) {
        // 先判断栈是否为空
        if(Empty(S)) {
            std::cout << "栈为空" << std::endl;
            return;
        }

        // 从栈顶开始遍历整个栈，同时打印每个元素的值
        for (int i = S.top; i >= 0; i--) {
            std::cout << S.data[i] << " ";
        }
        std::cout << std::endl;
    }
    ```

10. **销毁操作**
    1. 对于静态数组实现的栈，只需要把栈顶指针重置就行
    ```
    // 销毁操作
    void DestroyStack(SequenceStack &S) {
        S.top = -1;  // 对于静态数组实现的栈，只需要重置栈顶指针
    }
    ```