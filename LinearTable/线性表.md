# 第一章 线性表

- **线性表** 是一种 **逻辑结构** ，存储 **相同数据类型** 的n个 **数据元素** 的 **有限序列**

- 线性表有两种**表示方法**：**顺序表示** 和 **链式表示**

- 用顺序表示的线性表叫 **顺序表**

- 用链式表示的线性表叫 **链表**

- 顺序表中用 **静态分配** 方式实现的叫 **静态顺序表**  
  用 **动态分配** 方式实现的叫 **动态顺序表**

- **链表** 又可以分为 **单链表（带头结点/不带头结点）** 、**双链表** 、**循环链表（循环单链表/循环双链表）**


## 顺序表

**优点**：可以 **随机访问** ，在 $O(1)$ 时间内找到指定元素；**存储密度高**  
**缺点**：**插入和删除要移动大量元素**；  **拓展容量不方便**

### 静态顺序表的实现

1. 首先定义顺序表的 **最大表容量**
   ```
    #define MAX_SIZE 100  // 定义静态顺序表的最大长度
   ```

2. 然后设置静态顺序表的 **结构体** ,包括 **数据域** 和 **表长变量**
    ```
    // 静态顺序表结构体
    struct StaticSeqList {
        int data[MAX_SIZE];  // 静态数组：用于存储顺序表的元素
        int length;  // 当前顺序表的长度（即元素个数）
    };
    ```

3. **初始化** 线性表
    1. 传入 **表名 &L**
    2. 初始化 **表长变量为0**
   ```
    // 初始化顺序表
    void InitList(StaticSeqList &L){
        L.length = 0; // 将顺序表的长度初始化为0，表示空表
    }
   ```

4. **判空操作**
    - 返回表长是否为 0
    ```
    // 判空
    bool Empty(StaticSeqList L) {
        return L.length == 0;  // 返回表长是否为 0
    }
    ```

5. **插入操作** ：在第i个位置（指位序）插入元素e
    1. 传入 **表名 &L** 、**位序 i** 、**元素 e**  
    <u>注意：对表有修改行为时，有变动的参数前面需要加上 **&**</u>
    2. 判断传入的位序是否合法。不能为0，最大可以插在最后一个元素的后面
    3. 判断表是否已满。就看当前表长有没有到最大表长
    4. 把当前表内第 i 个元素和它后面的元素都往后移一位，从最后一个元素开始移。把前面元素的值赋给后面元素
    5. 把 e 的值赋给第 i 个元素
    6. 表长增一
   ```
    // 在顺序表第i个元素插入元素e
    bool ListInsert(StaticSeqList &L, int i, int e) {
        // 判断插入位置是否合法，i是位序，在1 ~ length+1之间
        if(i < 1 || i > L.length +1)
            return false;
        // 判断表是否已满
        if(L.length >= MAX_SIZE)
            return false;
        
        // 将第i个元素及其后面的元素都后移一个位置（从最后一个元素开始移动）
        for(int j = L.length; j >= i; j--) {
            L.data[j] = L.data[j - 1];  // 把前一个位置的元素赋值给当前位置
        }
        L.data[i - 1] = e;  // 在位置为i-1（数组下标）除插入元素e
        L.length++;  // 表长增加1
        return true;
    }
   ```

6. **删除操作** ：删除表中第 i 个位置的元素，并用 e 返回
    1. 传入 **表名 &L** 、**位序 i**、 **元素 &e**
    2. 判断传入的位序是否合法。不能为0，也不能超过当前表长
    3. 用 e 保存被删除元素的值
    4. 把第 i 个元素后面的所有元素都往前移一位，从第一个元素开始移。把后面元素的值赋给前面元素的值
    5. 表长减一
   ```
    // 删除顺序表第i个位置的元素，并用e返回
    bool ListDelete(StaticSeqList &L, int i, int &e) {
        // 判断删除位置是否合法， i必须在1~length之间
        if(i < 1 || i > L.length)
            return false;

        // 保存被删除元素的值
        e = L.data[i - 1];

        // 将第i个元素之后的元素向前移一个位置（从第i个位置开始）
        for(int j = i; j < L.length; j++) {
            L.data[j - 1] = L.data[j];  // 将后一个位置的元素赋值给前一个位置
        }
        L.length--;  // 表长减1
        return true;
    }
   ```

7. **按值查找** ：查找表中第一个值为 e 的元素的位序，找不到返回 0
    1. 传入 **表名 L** 、**值 e** 
    2. 遍历表中的所有元素（从数组下标0开始）
    3. 如果当前元素值为 e ，则返回当前元素的位序（数组下标加1）
    4. 找不到返回0
   ```
    // 按值查找：返回顺序表中第一个值为e的元素的位序，找不到返回0
    int LacateElem(StaticSeqList L, int e) {
        for(int i = 0; i < L.length; i++) {
            if(L.data[i] == e)
                return i + 1;  // 返回位序
        }
        return 0;
    }
   ```

8. **按位查找** ：返回表中第 i 个位置的元素的值
    1. 传入 **表名 L** 、**位序 i**
    2. 判断输入是否合法
    3. 直接返回数组下标为 i - 1 的元素值
   ```
    // 按位查找：返回顺序表中第i个元素的值
    int GetElem(StaticSeqList L, int i) {
        // 判断输入是否合法
        if(i < 1 || i > L.length)
            return -1;
        
        return L.data[i - 1];  // 第i个元素存放在数组中的第i-1个位置
    }
   ```

9. **求表长**
    - 直接返回表长
    ```
    int Length(StaticSeqList L) {
        return L.length;
    }
    ```

10. **遍历打印顺序表** ：按顺序把表里的元素打印出来
    1. 传入 **表名 L**
    2. 遍历整个表
    3. 遍历时输出元素的值
    ```
    // 遍历打印顺序表
    void PrintList(StaticSeqList L) {
        for(int i = 0; i < L.length; i++) {
            std::cout << L.data[i] << " ";
        }
        std::cout << std::endl;
    }
    ```

11. **清空静态顺序表**
    - 只需把表长重置为空，数组中的数据会被覆盖不用理会。
    ```
    // 清空静态顺序表
    void ClearList(StaticSeqList & L) {
        L.length = 0;
    }
    ```


### 动态顺序表的实现

1. 首先设置动态顺序表的 **结构体** ，包括 **指针** 、**当前最大容量** 、**当前长度** 。指针指向这一片存储空间的开始地址。
    ```
    #include <cstdlib>  // 包含malloc和free函数

    // 动态顺序表结构
    struct DynamicSeqList {
        int *data;  // 指向动态分配数组的指针，指向这一片存储空间的存储地址
        int maxSize;  // 数组的最大容量
        int length;  // 当前长度
    };
    ```


2. **初始化** 顺序表
    1. 传入 **表名 &L** 、**初始分配大小 size**
    2. 申请 size 个大小为 int 的空间，并用 malloc 函数返回一个强制转换为特定类型的指向这片空间开始地址的指针
    3. 当前最大容量设为 size
    4. 当前长度设为 0
    ```
    // 初始化动态顺序表，size为初始分配的大小
    void InitList (DynamicSeqList &L, int size) {
        L.data = (int *)malloc(size * sizeof(int));  // 申请size个大小为int的空间，并用malloc函数返回一个强制转换为int类型的指向这片空间开始地址的指针
        if(!L.data)
            exit(1);  // 如果分配失败，则退出程序
        L.length = 0;  // 初始长度为0
        L.maxSize = size;  // 记录最大容量
    }
    ```

3. **判空**
    - 返回表长是否为 0
    ```
    // 判空
    bool Empty(DynamicSeqList L) {
        return L.length == 0;
    }
    ```

4. **扩容** ：增加容量
    1. 传入 **表名 &L** 、 **增加的长度 len**
    2. 新建一个指针，把原指针赋给他，用来保存
    3. 用 malloc 申请一个比原最大容量还大 len 个的空间
    4. 如果分配失败就退出程序
    5. 如果分配成功，就把原数组的元素复制到新数组
    6. 更新当前最大容量
    7. 用 free 方法释放原空间
    ```
    // 增加动态顺序表的容量（增加len个长度）
    void IncreaseSize(DynamicSeqList &L, int len) {
        int *p = L.data;  // 保存原数组指针
        // 申请新的更大的空间
        L.data = (int *)malloc((L.maxSize + len) * sizeof(int));
        if(!L.data)
            exit(1);  // 如果分配失败，则退出程序
        
        // 将原数组的元素复制到新数组
        for(int i = 0; i < L.length; i++) {
            L.data[i] = p[i];
        }
        L.maxSize += len;  // 更新最大容量
        free(p);  // 释放原空间
    }
    ```

5. **插入** ：在第 i 个位置插入元素 e。（与静态顺序表相同）
    ```
    // 在顺序表第i个位置插入元素e
    bool ListInsert(DynamicSeqList &L, int i, int e) {
        // 判断插入位置是否合法，i必须在1~length+1之间
        if(i < 1 || i > L.length + 1) 
            return false;
        // 判断表是否已满，若已满则增加表容量
        if(L.length >= L.maxSize)
            IncreaseSize(L, 10);

        // 将第i个元素及其后面的元素往后移一个位置（从最后一个元素开始）
        for(int j = L.length; j >= i; j--) {
            L.data[j] = L.data[j - 1];  // 将前一个位置的元素赋值给当前位置
        }
        L.data[i -1] = e;  // 当位置i-1出插入元素e
        L.length++;  // 表长加1
        return true;
    }
    ```

6. **删除** ：删除第 i 个元素，并用 e 返回（与静态顺序表相同）
    ```
    // 删除表中第i个元素，并用e返回
    bool ListDelete(DynamicSeqList &L, int i, int &e) {
        // 判断删除位置是否合法，i必须要在1~length之间
        if(i < 1 || i > L.length)
            return false;
        e = L.data[i -1];  // 保存被删除元素的值

        // 将第i个元素之后的所有元素前移一位（从第一个元素开始）
        for(int j = i; j < L.length; j++) {
            L.data[j - 1] = L.data[j];  // 将后一个位置的元素赋值给前一个元素
        }
        L.length--;  // 表长减1
        return true;
    }
    ```

7. **按值查找** ：查找表中第一个值为 e 的元素的位序，找不到返回 0（与静态顺序表相同）
    ```
    // 按值查找：找到第一个值为e的元素的位序，找不到返回0
    int LocateElem(DynamicSeqList L, int e) {
        for(int i = 0; i < L.length; i++) {
            if(L.data[i] == e)
                return i + 1;  // 返回位序
        }
        return 0;  // 未找到
    }
    ```

8. **按位查找** ：返回表中第 i 个位置的元素的值（与静态顺序表相同）
    ```
    // 按位查找：返回列表中第i个元素的值
    int GetElem(DynamicSeqList L, int i) {
        return L.data[i -1];
    }
    ```

9. **求表长**
    - 返回表长
    ```
    // 求表长
    int Length(DynamicSeqList L) {
        return L.length;
    }
    ```

10. **遍历打印顺序表** （与静态顺序表相同）
    ```
    // 遍历打印顺序表
    void PrintList(DynamicSeqList L) {
        for(int i = 0; i < L.length; i++){
            std::cout << L.data[i] << " ";
        }
        std::cout << std::endl;
    }
    ```

11. **销毁操作**
    - 先释放数据域空间
    - 再把指针指向空
    - 最后把表长和最大表容量置为 0
    ```
    // 销毁操作
    void DestroyList(DynamicSeqList &L) {
        free(L.data);
        L.data = nullptr;
        L.length = 0;
        L.maxSize = 0;
    }
    ```


## 链表

### 单链表

#### 带头结点的单链表的实现

1. 首先定义单链表的 **结点结构**。
    - 包括一个 **数据域 data** 和一个结点类型 **指针域 next**。这个指针指向的是下一个结点的空间地址
    ```
    // 单链表节点结构
    struct LNode {
        int data;  // 数据域
        LNode *next;  // LNode类型的指针域，指向下一个节点
    };
    ```

2. **初始化** 带头结点的单链表
    1. 传入 **头指针 \*&L** 的值。
         - 因为初始化要创建一个头结点，也就是说头指针 L 的值从 nullptr 指向了新创建的头结点，所以修改了 L 的值那就要加返回符 *&*。  
        - <u>头指针同时也是一个单链表的标识</u>
    2. 创建一个 **头结点 L**。
    3. 把头结点 L 的 **next 指向 nullptr**
    ```
    // 初始化单链表
    void InitList(LNode *&L) {
        L = new LNode;  // 创建一个头结点
        L -> next = nullptr;  // 头结点的next设为空
    }
    ```

3. **判空**
    - 返回头结点的 next 是否为空
    ```
    // 判空
    bool Empty(LNode *L) {
        return L -> next == nullptr;
    }
    ```

4. **头插法** 插入新结点 e ：把新元素都插到头结点的后一个位置上
    1. 传入 **头指针 \*L** 、**新结点 e** 。
        - 因为是带头结点的单链表，所以头指针的值不会变，始终指向头结点，因此不用带返回符 &
    2. 新建一个结点 s
    3. 把 e 的值赋给 s 的数据域
    4. 把 s 的 next 指向头结点 L 的 next 域
    5. 头结点 L 的 next 指向 s
    ```
    // 头插法插入元素（在头结点之后插入）
    void HeadInsert(LNode *L, int e) {
        LNode *s = new LNode;  // 新建一个结点
        s -> data = e;  // 把 e 赋值给s的数据域
        s -> next = L -> next;  // 把新结点的next指向头结点的next
        L -> next = s;  // 把头结点的next指向s
    }
    ```

5. **尾插法** 插入新结点 e ：把新结点插到链表的末尾
    1. 传入 **头指针 \*L** 、**新结点 e**
    2. 新建一个结点 s 
    3. 把 e 的值赋给 s 的数据域
    4. 把 s 的 next 指向 nullptr
    5. 新建一个指针 *p ，并让他指向头结点 L
    6. 找到尾结点
        - 遍历整个链表，直到 p 的 next 为 nullptr ，表示当前结点为尾结点
    7. 把尾结点 p 的 next 指向 s
    ```
    // 尾插法插入元素（在链表尾部插入）
    void TailInsert(LNode *L, int e) {
        LNode *s = new LNode;  // 新建一个结点
        s -> data = e;  // 把 e 赋给s的数据域
        s -> next = nullptr;  // 把新结点的next指向空

        LNode *p = L;  // 新建一个指针P，指向头结点
        while(p -> next) {
            p = p -> next;  // 从头结点开始循环整个链表，直到找到当前链表内next指向空的尾结点
        }
        p -> next = s;  // 把s结点放到链表尾部
    }
    ```

6. **按位删除** （删除第 i 个位置的结点，并用 e 返回）
    1. 传入 **头指针 \*L** 、**位置 i** 、**返回值 &e**
    2. 判断输入是否合法。 i 的值不能为 0
    3. 新建一个指针 *p ，让它指向头结点 L
    4. 设置一个计数器 j , 表示当前指向第几个结点。默认设为 0（头结点表示为 0 ）
    5. 找到被删除结点的前一个结点
        - 遍历整个链表，直到 j = i-1，表示当前结点为被删除结点的前一个结点
        - 如果遍历时 指针 p 的 next 指向了 nullptr 即指向了最后一个元素，则说明输入的位置超过了表长
    6. 再新建一个指针 *q ,让它指向被删除的结点 p -> next
    7. 用 e 记录被删除结点 p 的数据域的值
    8. 把被删除结点的前一个结点 p 的 next 指向 被删除结点 q 的下一个结点
    9. 释放被删除结点 p 的空间
    ```
    // 按位删除（删除第i个结点，并返回其值）
    bool ListDelete(LNode *L, int i, int &e) {
        if(i < 1)
            return false;  // 判断输入是否合法，删除位置不能为0，是否超过表长+1在后面判断

        // 首先要找到被删除结点的前一个结点
        LNode *p = L;  // 新建一个指针P，指向头结点
        int j = 0;  // 设置一个计数器，记录当前是第几个结点
        while(p -> next && j < i - 1) {
            p = L  -> next;  // 循环查找，直到找到第i-1个结点
            j++;  // 计数器加一
        }
        if(!p -> next)
            false;  // 若p的next指向空，则说明i超出表长+1
            
        LNode *q = p -> next;  // 新建一个指针q，指向被删除的结点
        e = q -> data;  // 用e记录被删除结点的值
        p -> next = q -> next;  // 把被删除结点的前一个结点的next指向被删除结点的下一个结点
        delete q;  // 释放被删除结点的空间
        return true;
    }
    ```

7. **按值查找**
    - 传入 **头指针 \*L** 、 **要查找的值 e**
    - 新建一个指针，指向第一个结点（不是头结点）
    - 设置一个计数器，表示当前指向第几个结点，默认为 1 ，指向第一个结点
    - 遍历整个链表，找到第一个值为 e 的元素，若找到则返回位序，若没找到则返回 0
    ```
    // 按值查找（找到第一个值为 e 的元素的位序，找不到返回 0
    int LocateElem(LNode *L, int e) {
        LNode *p = L -> next;  // 新建一个指针 p ，指向头结点后的第一个结点
        int j = 1;  // 新建一个计数器，用来表示当前指向第几个结点，初始为 1 ，指向第一个结点
        while(p) {
            if(p -> data == e)
                return j;  // 若找到则返回位序
            j++;
            p = p -> next;
        }
        return 0;  // 未找到
    }
    ```

8. **按位查找**
    - 传入 **头指针 \*L** 、 **要查找的位序 i**
    - 先判断输入位置是否合法，不可以小于 1
    - 新建一个指针，指向第一个结点
    - 遍历链表，找到第 i 个结点
    - 如果没找到说明超过了表长
    - 如果找到了就返回元素的值
    ```
    // 按位查找（返回表中第 i 个位置的元素的值）
    int GetElem(LNode *L, int i) {
        // 先判断输入是否合法，查询位置不可以小于 0
        if(i < 1)
            return false;

        LNode *p = L -> next;  // 新建一个指针 p ，指向头结点后的第一个结点
        int j = 1;  // 新建一个计数器，用来表示当前指向第几个结点
        // 找到第 i 个结点
        while(p && j < i) {
            j++;
            p = p -> next;
        }
        if(!p)  // 如果没有找到第 i 个结点，说明超过了表长
            return false;
        
        return p -> data;
    }
    ```

9.  **交换位置** （把第 i 个结点和前驱结点交换）
    1. 传入 **头指针 \*L** 、**交换的结点 i**
    2. 找到第 i 个结点的 **前驱结点的前驱结点**
        - 新建一个指针 **\*w** ，指向头结点
        - 设置一个 **计数器 j** ，记录当前指向第几个结点，默认为 0 ，指向头结点
        - 找到第 i - 2 个结点
            - 遍历整个链表，直到找到第 i - 2 个结点
            - 如果当前遍历的结点的 next 的 next 为空，则说明没有第 i 个结点
    3. 新建一个指针 **\*q** ，指向第 i - 1 个结点
    4. 新建一个指针 **\*p** ，指向第 i 个结点
    5. 新建一个指针 **\*e** ，指向第 i + 1 个结点
    6. 把第 i - 2 个结点指向第 i 个结点
    7. 把第 i 个结点的 next 指向第 i - 1 个结点
    8. 把第 i - 1 个结点的 next 指向第 i + 1 个结点
    ```
    // 交换位置（把第 i 个结点和前驱结点交换）
    bool Transform(LNode *L, int i) {
        if(i < 1) 
            return false;  // 判断输入是否合法

        // 首先找到第 i 个结点的前驱结点的前驱结点
        LNode *w = L;  // 新建一个指针，指向头结点
        int j = 0;  // 设置一个计数器，记录当前指向第几个结点，默认为0， 指向头结点
        while(w -> next && j < i - 2) {
            w = w -> next;
            j++;
        }
        if(!w -> next -> next) {
            return false;
        }
        
        LNode *q = w -> next;  // 新建一个指针 q ，指向第 i-1 个结点
        LNode *p = q -> next;  // 新建一个指针 p ，指向第 i 个结点
        LNode *e = p -> next;  // 新建一个指针 e ，指向第 i+1 个结点

        w -> next = p;  // 先把第 i-2 个结点的next 指向第 i 个结点
        p -> next = q;  // 把第 i 个结点的 next 指向第 i 个结点的前驱结点
        q -> next = e; // 最后把第 i-1 个结点的next指向 第i+1个结点

        return true;
    }
    ```

10. **求表长**
    - 传入 **头指针 \*L**
    - 新建一个指针 p ，指向第一个结点
    - 设置一个计数器，表示已经记录了多少个结点
    - 遍历整个链表，每遍历一个就记录一个
    - 最后返回计数结果
    ```
    // 求表长
    int Length(LNode *L) {
        LNode *p = L -> next;  // 新建一个指针 p ，指向第一个结点（不是头结点）
        int length = 0;  // 设置一个计数器，表示当前表长

        while(p) {
            length++;
            p = p -> next;;
        }
        return length;
    }
    ```

11. **遍历打印单链表**
    1. 传入 **头指针 \*L**
    2. 新建一个指针 *p ，并让它指向头结点的下一个结点
    3. 遍历整个单链表，同时打印当前结点的数据域，直到指针指向 nullptr
    ```
    // 遍历打印链表
    void PrintList(LNode *L) {
        LNode *p = L ->next;  // 新建一个指针p， 指向头结点后的第一个结点
        while(p) {
            std::cout << p -> data << " ";  // 打印出当前结点的数据域
            p = p -> next;  // 打印完p指针指向下一个结点
        }
        std::cout << std::endl;  // 换行
    }
    ```

12. **销毁操作**
    - 传入 **头指针 \*&L**
    - 新建一个指针 p ，指向第一个结点
    - 删除结点
      - 遍历整个链表
      - 新建一个指针 temp ，指向 p 指向的结点
      - 删除 temp 指向的结点
    - 删除头结点
    - 头指针指向空
    ```
    // 销毁操作
    void DestroyList(LNode *&L) {
        LNode *p = L -> next;  // 新建一个指针 p ，指向第一个结点
        while(p) {
            LNode *temp = p;  // 新建一个指针 temp ，指向第一个结点
            p = p -> next;
            delete temp;  // 删除结点
        }
        delete L;  // 删除头结点
        L = nullptr;  // 头指针指向空
    }
    ```


#### 不带头结点的单链表的实现

1. 首先定义单链表的 **结点结构**
    - 包括一个 **数据域 data** 和一个 **指针域 *next***，这个指针指向的是下一个结点的空间地址
    ```
    // 不带头结点的单链表结点结构
    struct LNode {
        int data;  // 数据域
        LNode *next;  // 指针域
    };
    ```

2. **初始化** 单链表
    1. 传入 **头指针 \*&L**
    2. 让头指针 L 指向 nullptr
    ```
    // 初始化单链表
    void InitList(LNode *&L) {
        L = nullptr;  // 因为不带头结点，就将头指针指向空
    }
    ```

3. **判空操作**
    - 传入 **头指针 \*L**
    - 返回头指针是否指向空
    ```
    // 判空操作
    bool Empty(LNode *L) {
        return L == nullptr;
    }
    ```

4. **插入** （在第 i 个位置插入 e ）
    1. 传入 **头指针 \*&L** ， **插入位置 i**， **返回值 e**
    2. 判断输入是否合法，位置 i 不能小于 1
    3. 如果是在表头位置插入
        1. 新建一个结点 s
        2. 把 e 的值赋给 s 的数据域
        3. 让 s 的 next 指向当前的第一个结点 L
        4. 让头指针 L 指向 s
    4. 如果不是插在表头位置
        1. 新建一个结点 s
        2. 把 e 的值赋给 s 的数据域
        3. 找到第 i-1 个结点
            - 创建一个指针 *p ,指向头结点
            - 设置一个计数器，记录当前指向第几个结点，初始设为 1 （没有头结点）
            - 遍历这个链表，直到 j = i-1 ，表示找到了第 i-1 个结点
            - 如果指针 p 指向 nullptr ，则说明插入位置超过了 表长+1
        4. 把 s 的 next 指向 p 的 next 即指向第 i 个位置的结点
        5. 让 p 的 next 指向 s ，即把 p 和 s 连起来
    ```
    // 插入操作，在第i个位置插入e
    bool ListInsert(LNode *&L, int i, int e) {
        if(i < 1) {
            false;  // 判断输入是否合法，位置不能小于1
        }
        else if(i == 1) {  // 若在第一个位置插入
            LNode *s = new LNode;  // 创建一个新结点s
            s -> data = e;  // 把e的值赋给s的数据域
            s -> next = L;  // 把新建的s结点的next指向当前第一个结点L
            L = s;  // 把头指针指向s
        }
        else {
            LNode *p = L;  // 新建一个指针p，指向当前第一个结点
            int j = 1;  // 用来记录当前指向第几个结点，默认当前指向一号
            while(p && j < i - 1) {  // 找到插入位置的前一个结点
                p = p -> next;
                j++;
            }
            if(!p)
                return false;  // 插入位置前一个结点为空，说明此位置超过了表长+1

            LNode *s = new LNode;  // 新建一个结点s
            s -> data = e;  // 把e赋给s的数据域
            s -> next = p -> next;  // 让s的next指向被插入位置上的结点
            p -> next = s;  // 把插入位置前一个结点和新结点连接起来
        }
        return true;
    }
    ```

5. **删除** （删除第 i 个位置的结点，并用 e 返回）
    1. 传入 **头指针 \*&L** ，**删除位置 i** ， **返回值 &e**
    2. 判断删除位置是否合法， i 不能小于 1
    3. 如果删除第一个结点
        1. 新建一个指针 *p ，指向第一个结点 L
        2. 用 e 保存头结点的值
        3. 让头指针 L 指向第二个结点 L -> next
        4. 释放 p 指针的空间
    4. 如果删除的是其他结点，那就找到被删除结点的前一个结点
        1. 新建一个指针 *p ,指向第一个结点
        2. 设置一个计数器， 表示当前指向第几个结点，默认设为 1 （没有头结点）
        3. 遍历整个链表，直到找到第 i-1 个结点
            - 如果 p -> next 等于 nullptr ，那就表示传入的位置超出了表长
        4. 新建一个指针 *q ,指向被删除的结点 p -> next
        5. 用 e 返回被删除结点的值 q -> data
        6. 把被删除结点的前一个结点的 next 指向被删除结点 q 的 next
        7. 释放被删除结点的空间 q
    ```
    // 删除操作（删除第i个结点，并返回其值
    bool ListDelete(LNode *&L, int i, int &e) {
        if(i < 1) {
            return false;  // 删除位置不能小于1
        }
        // 若删除第一个结点
        else if(i == 1) {
            LNode *p = L;  // 新建一个指针p，指向当前表中第一个结点
            e = p -> data;  // 用e返回被删除结点的值
            L = L -> next;  // 把头指针指向第二个结点
            delete p;  // 删除第一个结点
        }
        else{
            // 找到被删除结点的前一个结点
            LNode *p = L;  // 新建一个指针p，指向当前第一个结点
            int j = 1;  // 记录当前是第几个结点，默认指向第一个
            while(p -> next && j < i - 1) {
                p = p -> next;
                j++;
            }
            if(!p -> next) 
                return false;  // 说明第i个位置没有结点，超出了表长
        
            LNode *q = p -> next;  // 新建一个指针q，指向被删除的结点
            e = q -> data;  // 用e返回被删除结点的值
            p -> next = q -> next;  // 把第i-1个结点的next指向被删除结点的下一个结点
            delete q;  // 释放被删除结点的空间
        }
        return true;
    }
    ```

6. **按值查找**
    - 传入 **头指针 \*L** 、**要查找的元素 e**
    - 新建一个指针 p ，指向表头结点
    - 设置一个计数器，记录当前指向第几个结点
    - 遍历整个链表
    - 如果找到值为 e 的结点，就返回其位序
    - 如果没有找到就返回 0
    ```
    // 按值查找（查找第一个元素值为 e 的元素，并返回其位序，未找到则返回 0）
    int LocateElem(LNode *L, int e) {
        LNode *p = L;  // 新建一个指针 p ，指向表中的第一个结点
        int j = 1;  // 设置一个计数器，记录当前指向第几个结点，默认为 1 ，指向第一个结点

        while(p) {
            if(p -> data == e) 
                return j;  // 若找到，则返回位序
            p = p -> next;
            j++;
        }
        return 0;
    }
    ```

7. **按位查找**
    - 传入 **头指针 \*L** 、**要查找的位序 i**
    - 初步判断输入是否合法， i 不能小于 1
    - 新建一个指针 p ，指向表头结点
    - 设置一个计数器，记录当前指向第几个结点
    - 遍历整个链表，找到第 i 个结点
    - 如果没找到就返回 0
    - 如果找到了就返回其值
    ```
    // 按位查找（查找表 L 中第 i 个位置的元素的值）
    int GetElem(LNode *L, int i) {
        // 判断输入是否合法
        if(i < 1)
            return 0;
        
        LNode *p = L;  // 新建一个指针 p ，指向第一个结点
        int j = 1;  // 设置一个计数器，记录当前指向的是第几个结点，默认为 1 ，指向第一个结点
        while(p && j < i) {
            p = p -> next;
            j++;
        }
        if(!p)
            return 0;
        
        return p -> data;  // 若找到了，就返回其值
    }
    ```

8. **求表长**
    - 传入 **头指针 \*L**
    - 判断链表是否为空，为空则返回 0
    - 新建一个指针 P ，指向表头结点
    - 设置一个计数器，表示当前记录的表长，默认为 1
    - 遍历整个链表，每遍历一个结点就记录一次
    - 最后返回记录的表长
    ```
    // 求表长
    int Length(LNode *L) {
        // 判断是否为空，若为空则返回 0
        if(Empty(L))
            return 0;

        LNode *p = L;  // 新建一个指针，指向第一个节点
        int length = 1;  // 设置一个计数器，表示当前指向第几个结点
        while(p -> next) {
            p = p -> next;
            length++;
        }
        return length;
    }
    ```

9.  **遍历打印单链表**
    1. 传入 **头指针 \*L**
    2. 新建一个指针 *p ，指向第一个节点 L
    3. 遍历整个链表，同时输出当前结点的值，直到 p 为空
    ```
    // 遍历打印单链表
    void PrintList(LNode *L) {
        LNode *p = L;  // 新建一个指针p，指向表中第一个结点
        while(p) {
            std::cout << p -> data << " ";  // 打印当前结点的值
            p = p -> next;
        }
        std::cout << std::endl;    
    }
    ```

10. **销毁操作**
    - 传入 **头指针 \*&L**
    - 新建一个指针 p ，指向表头结点
    - 遍历整个链表，删除结点
      - 新建一个指针 temp ，指向 p 指向的结点
      - 删除 temp 当前指向的结点
    - 最后把头指针指向空
    ```
    // 销毁操作
    void DestroyList(LNode *&L) {
        LNode *p = L;  // 新建一个指针 p ，指向第一个结点
        while(p) {
            LNode *temp = p;  // 新建一个指针 temp ，指向 p 指向的结点
            p = p -> next;
            delete temp;  // 删除 temp 指向的结点
        }
        L = nullptr;  // 头指针指向空
    }
    ```


### 双链表的实现
**特点** ：双链表不可随机存取、随机查找（按位/按值），只能通过遍历实现

1. 首先定义双链表的 **结点结构** 。包括一个 **数据域** 、**指向前驱的指针** 、**指向后继的指针**
    ```
    // 带头结点的双链表结点结构
    struct DNode {
        int data;  // 数据域
        DNode *prior;  // 指向前驱的指针
        DNode *next;  // 指向后继的指针 
    };
    ```

2. **初始化**
    1. 传入 *头指针 \*&L* ，让头指针指向头结点
    2. 创建一个头结点 L
    3. 把前驱指针 prior 指向 nullptr (头结点的前驱指针 prior 永远指向空)，把后继指针 next 指向空，因为当前没有其他结点
    ```
    // 初始化双链表
    void InitList(DNode *&L) {
        L = new DNode;  // 新建一个头结点
        L -> prior = nullptr;  // 双链表的头结点的 prior 指针永远指向空
        L -> next = nullptr;  // 当前没有其他结点，头结点的 next 指向空
    }
    ```

3. **判空**
    - 直接返回头结点的 next 是否为空
    ```
    // 判空
    bool Empty(DNode *L) {
        return L -> next == nullptr;  // 返回头结点的 next 是否为空
    }
    ```

4. **插入** （在第 i 个位置插入结点 e ）
    1. 传入 *头指针 L* 、*插入位置 i* 、*插入的值 e*
    2. 判断插入位置是否合法，i 不能为0
    3. 找到插入位置的前一个结点
        1. 新建一个指针 p，指向头结点
        2. 设置一个计数器，记录当前指向第几个结点，默认设为 0 （头结点记为 0 ）
        3. 遍历整个链表，直到 j = i-1
        4. 如果 p 指向空，即插入位置的前一个结点为空，就说明插入位置超过了表长
    4. 新建一个结点 s
    5. 把 e 的值赋给 s 的数据域
    6. 让新结点 s 的 next 指向 p 的 next
    7. 如果 p 结点后面还有结点，那么就把 p 后面的结点的 prior 指向 s
    8. 把 s 的 prior 指向 p 结点
    9. 把 p 结点的 next 指向 s

5. **删除** （删除第 i 个位置的结点，并用 e 返回）
    1. 传入 *头指针 L* 、*删除位置 i* 、*返回值 e*
    2. 判断删除位置是否合法，i 不能为 0
    3. 找第 i 个位置的结点
        1. 新建一个指针 p ，让它指向头结点之后的第一个结点
        2. 设置一个计数器，记录当前指向第几个结点。默认为 1（指向头结点之后的第一个结点）
        3. 遍历整个链表，直到 j = i
        4. 如果遍历过程中 p 指向空，则说明第 i 个位置没有结点，输入的位置 i 不合法
    4. 直到第 i 个结点后，用 e 返回 p 的值
    5. 再把结点 p 的前一个结点的 next 指向 p 的后一个结点
    6. 如果 p 结点后还有结点，就把后面的这个结点的 prior 指向 p 的前一个结点
    7. 释放被删除结点 p 的空间

6. **按值查找**
    - 传入 **头指针 \*L** 、 **要查找的值 e**
    - 新建一个指针 p ，指向第一个结点（不是头结点）
    - 设置一个计数器，记录当前指向第几个结点
    - 遍历整个链表
    - 如果找到值为 e 的结点，就返回其位序
    - 如果没找到就返回 0
    ```
    // 按值查找
    int LocateElem(DNode *L, int e) {
        DNode *p = L -> next;  // 新建一个指针 p ，指向第一个结点
        int j = 1;  // 设置一个计数器，记录当前指向第几个结点，默认为 1 ，指向第一个结点
        while(p) {
            if(p -> data == e) 
                return j;
            p = p -> next;
            j++;
        }
        return 0;  // 未找到则返回 0
    }
    ```

7. **按位查找**
    - 传入 **头指针 \*L** 、 **要查找的位序 i**
    - 先判断输入是否合法，输入的位序不能小于 1
    - 新建一个指针 p ，指向第一个结点
    - 设置一个计数器，记录当前指向第几个结点
    - 遍历整个链表，找到第 i 个结点
    - 如果没找到就返回 -1
    - 如果找到了，就返回其值
    ```
    // 按位查找
    int GetElem(DNode *L, int i) {
        // 判断输入是否合法，不能小于 1
        if(i < 1) 
            return -1;
        
        DNode *p = L -> next;  // 新建一个指针，指向第一个结点
        int j = 1;  // 设置一个计数器，记录当前指向第几个结点
        // 遍历整个链表，找到第 i 个结点
        while(p && j < i) {
            p = p -> next;
            j++;
        }
        if(!p)  // 若没找到则返回 -1
            return -1;
        // 若找到，则返回其值
        return p -> data;
    }
    ```

8. **求表长**
    - 传入 **头指针 \*L**
    - 设置一个表长计数器 **length** ，记录当前表长
    - 新建一个指针 p ，指向第一个结点
    - 遍历整个链表，每遍历一个结点就记录一个
    - 最后返回表长
    ```
    // 求表长
    int Length(DNode *L) {
        int length = 0;  // 设置一个表长计数器，记录表长
        DNode *p = L -> next;  // 新建一个指针 p ，指向第一个结点
        //遍历整个链表，每遍历一个结点就记录一个
        while(p) {
            length++;
            p = p -> next;
        }
        // 返回表长
        return length;
    }
    ```

9. **后向遍历打印链表**
    - 传入 **头指针 \*L**
    - 新建一个指针 p ，指向第一个结点
    - 遍历整个链表，同时打印数据域
    ```
    // 遍历打印链表
    void PrintList_BackwardTraversal(DNode *L) {
        DNode *p = L -> next;  // 新建一个指针 p ，指向第一个结点
        while(p) {
            std::cout << p -> data << " ";  // 遍历输出当前结点的值
            p = p -> next;
        }
        std::cout << std::endl;  // 换行
    }
    ```

10. **前向遍历**
    ```
    while(p)
        p = p ->prior;
    ```

11. **前向遍历（跳过头结点）
    ```
    while(p -> prior)
        p = p -> prior;
    ```

12. **销毁操作**
    - 传入 **头指针 \*&L**
    - 新建一个指针 p ，指向第一个结点
    - 遍历整个链表
      - 新建一个指针 temp ，指向 P 指向的结点
      - 删除 temp 指向的结点
    - 删除头结点
    - 把头指针指向空
    ```
    // 销毁操作
    void DestroyList(DNode *&L) {
        DNode *p = L -> next;  // 新建一个指针 P ，指向第一个结点
        while(p) {
            DNode *temp = p;  // 新建一个指针 temp ，指向 p 指向的结点
            p = p -> next;
            delete temp;  // 删除结点
        }
        delete L;  // 删除头结点
        L = nullptr;  // 头指针指向空
    }
    ```


### 循环链表

#### 循环单链表（有头结点）的实现
1. 首先定义循环单链表的 **结点结构** ，包括一个 **数据域** 和一个 **指针域**
    ```
    // 定义循环单链表的结点结构
    struct CNode {
        int data;  // 数据域
        CNode *next;  // 指针域
    };
    ```

2. **初始化**
    1. 传入 **头指针 \*&L**
    2. 创建一个头结点
    3. 让头结点的 next 指向自己，形成循环
    ```
    // 初始化循环单链表
    void InitList(CNode *&L) {
        L = new CNode;  // 新建一个头结点
        L -> next = L;  // 让头结点的 next 域指向自己，形成循环
    }
    ```

3. **判空**
    1. 传入 **头指针 \*L**
    2. 返回头结点的 next 是否指向自己
    ```
    // 判空
    bool Empty(CNode *L) {
        return L -> next == L;  // 看头结点的 next 是否指向自己，如果是，则为空，如果不是，则不为空
    }
    ```

4. **是否为尾结点**
    1. 传入 **头指针 \*L** 、 **要判断的结点 p**
    2. 返回结点 p 的 next 是否指向头结点
    ```
    // 判断结点 p 是否为最后一个结点 
    bool isTail(CNode *L, CNode *p) {
        return p -> next == L;  // 看 p 的 next 是否指向头结点，如果是，则为最后一个结点，反之，不是最后一个结点
    }
    ```

5. **插入** （在 L 的第 i 个位置插入结点 e ）
    1. 传入 **头指针 \*L** 、**插入位置 i ** 、**插入结点 e**
    2. 判断插入位置是否合法，插入位置不可以为 0
    3. 找到删除位置的前一个结点
        1. 新建一个指针 p ，指向头结点，用于遍历整个链表
        2. 设置一个计数器，记录当前指向的是第几个结点，初始设为 0，表示当前指向的是头结点
        3. 遍历整个链表，直到找到第 i-1 个结点，遍历结束的标志为当前结点为尾结点。
            - 尾结点的标志为 next 指向了头结点
        4. 如果遍历完整个链表后 j 不等于 i ，就说明插入位置前没有结点，即插入位置超过了表长加一
    4. 新建一个结点 s
    5. 把 e 的值赋给 s
    6. 把 s 的 next 指向第 i 个位置的结点
    7. 把插入位置前面一个的结点 p 的 next 指向 s
    ```
    // 插入（在第 i 个位置插入一个结点 e）
    bool ListInsert(CNode *L, int i, int e) {
        if(i < 1)
            return false;  // 判断插入位置是否合法，i 不能为 0
        
        // 找到第 i-1 个结点
        CNode *p = L;  // 新建一个指针 p ，指向头结点
        int j = 0;  // 设置一个计数器，记录当前指向第几个结点，默认为 0 （头结点记为 0 ）
        while(p -> next != L && j < i - 1) {  // 遍历链表，直到找到第 i-1 个结点
            p = p -> next;
            j++;
        }
        if(j != i - 1) 
            return false;  //如果计数器未指向第 i-1 个结点，则说明位置 i 超过了 表长+1

        CNode *s = new CNode;  // 新建一个结点 s
        s -> data = e;  // 把 e 的值赋给 s
        s -> next = p -> next;  // 把新结点 s 的 next 指向第 i 个结点
        p -> next = s;  // 把第 i-1 个结点的 next 指向 s
        return true;
    }
    ```

6. **删除** （删除 L 的第 i 个结点，并用 e 返回）
    1. 传入 **头指针 \*L** 、**删除位置 i** 、**返回值 &e**
    2. 判断输入是否合法，删除位置 i 不能为 0
    3. 找到第 i - 1 个结点
        1. 新建一个指针 p ，指向头结点
        2. 设置一个计数器，记录当前指向第几个结点，默认为 0 （头结点记为 0 ）
        3. 遍历整个链表，找到第 i - 1 个结点
        4. 遍历完整个链表后没有找到第 i - 1 个结点，或者第 i - 1 个结点是尾结点，则说明删除位置超过了表长
        5. 新建一个指针 q ，指向被删除的结点
        6. 用 e 返回被删除结点的值
        7. 把第 i - 1 个结点的 next 指向被删除结点的后一个结点
        8. 释放被删除结点的空间
    ```
    // 删除（删除第 i 个位置的结点，并用 e 返回）
    bool ListDelete(CNode *L, int i, int &e) {
        // 判断删除位置是否合法，i 不能为 0
        if(i < 1)
            return false;

        // 找到第 i-1 个位置的结点
        CNode *p = L;  // 新建一个结点，指向头结点
        int j = 0;  // 设置一个计数器，记录当前指向第几个结点。默认为 0 （指向头结点）
        while(p -> next != L && j < i - 1) {  // 遍历整个链表，找到第 i-1 个结点
            p = p -> next;
            j++;
        }
        if(p -> next == L || j != i - 1) 
            return false;  // 如果遍历过程中，p 指向了尾结点，则说明删除位置 i 超过了表长

        CNode *q = p -> next;  // 新建一个指针 q ，指向被删除结点
        e = q -> data;  // 用 e 存储被删除结点的值
        p -> next = q -> next;  // 把结点 p 的 next 指向被删除结点后面的一个结点
        delete q;  // 释放被删除结点 q 的空间
        
        return true;
    }
    ```

7. **按值查找**
    1. 传入 **头指针 \*L** 、 **要查找的值 e**
    2. 新建一个指针 p ，指向头结点的下一个结点
    3. 设置一个计数器，记录当前指向第几个结点，默认为 1 ，指向第一个结点
    4. 遍历整个链表，找到值为 e 的结点。若找到就返回位序，没找到就返回 0
    ```
    // 按值查找
    int LocateElem(CNode *L, int e) {
        CNode *p = L -> next;  // 新建一个指针 p ，指向第一个结点
        int j = 1;  // 设置一个计数器，记录当前指向第几个结点
        while(p != L) {
            if(p -> data == e)
                return j;  // 如果找到就返回位序
            p = p -> next;
            j++;
        }
        return 0;  // 若没找到就返回 0
    }
    ```

8. **按位查找**
    1. 传入 **头指针 \*L** 、**要查找的位序 i**
    2. 先判断输入是否合法，查找位序不能小于 1
    3. 新建一个指针 p ，指向第一个结点
    4. 设置一个计数器，记录当前指向第几个结点，默认为 1 ，指向头结点
    5. 遍历整个链表，找到第 i 个结点
    6. 如果没找到就返回 -1
    7. 如果找到了就返回其值
    ```
    // 按位查找
    int GetElem(CNode *L, int i) {
        // 判断输入是否合法，不能小于 1
        if(i < 1)
            return -1;
        
        CNode *p = L -> next;  // 新建一个指针 p ，指向第一个结点
        int j = 1;  // 设置一个计数器，记录当前指向第几个结点
        while(p != L && j < i) {
            p = p -> next;
            j++;
        }
        if(p == L)
            return -1;  // 如果为找到就返回 -1
        return p -> data;  // 如果找到了就返回其值
    }
    ```

9. **求表长**
    1. 传入 **头指针 \*L**
    2. 设置一个表长计数器
    3. 新建一个指针 P ，指向第一个结点
    4. 遍历整个链表，每遍历一个结点就记录一次
    5. 最后返回表长
    ```
    // 求表长
    int Length(CNode *L) {
        int length = 0;  // 设置一个表长计数器
        CNode *p = L -> next;  // 新建一个指针 p ，指向第一个结点
        while(p != L) {
            length++;
            p = p -> next;
        }
        return length;  // 返回最终表长
    }
    ```

10. **遍历打印**
    1. 传入 **头指针 \*L**
    2. 新建一个指针 p ,指向头节点
    3. 遍历整个链表，同时打印每个结点的值
    ```
    // 遍历打印循环单链表
    void PrintList(CNode *L) {
        CNode *p = L -> next;  // 新建一个指针 p ，指向第一个结点
        while(p != L) {  // 遍历整个链表，并输出每个结点的值
            std::cout << p -> data << " ";
            p = p -> next;
        }
        std::cout << std::endl;  // 换行
    }
    ```

11. **销毁操作**
    1. 传入 **头指针 \*&L**
    2. 新建一个指针 p ，指向第一个结点
    3. 遍历整个链表
       1. 新建一个指针 temp ，指向 p 指向的结点
       2. 删除 temp 指向的结点
    4. 删除头节点
    5. 把头指针值为空
    ```
    // 销毁操作
    void DestroyList(CNode *&L) {
        CNode *p = L -> next;  // 新建一个指针 p ，指向第一个结点
        while(p != L) {
            CNode *temp = p;  // 新建一个指针 temp ，指向 p 指向的结点
            p = p -> next;
            delete temp;  // 删除 temp 指向的结点
        }
        delete L;  // 删除头结点
        L = nullptr;  // 把头指针置为空
    }
    ```


#### 循环双链表的实现

1. 首先定义循环双链表的 *结点结构* ，包括 *数据域* ，*指向前驱结点的指针 prior* ，*指向后继结点的指针 next*

2. *初始化*
    1. 传入 *头指针 \*&L*
    2. 创建一个头结点 L
    3. 把头结点的 prior 和 next 都指向自己

3. *插入* （在 L 的第 i 个位置插入结点 e）
    1. 传入 *头结点 \*L* 、*插入位置 i* 、*插入结点 e*
    2. 判断插入位置是否合法， i 不能为 0
    3. 找到插入位置的前一个结点
        1. 新建一个指针 p ，指向头结点
        2. 设置一个计数器，记录当前指向第几个结点，
        3. 遍历整个链表，找到第 i - 1 个结点
        4. 如果遍历完没有找到第 i - 1 个结点，那就说明插入位置超过了 表长+1
    4. 新建一个结点 s 
    5. 把 e 的值赋给 s
    6. 把 s 的 next 指向 p 的下一个结点，也就是第 i 个结点
    7. 把 s 的 prior 指向 p
    8. 把第 i 个结点的 prior 指向新结点
    9. 把第 i 个结点 p 的 next 指向新结点

4. *删除* （删除 L 的第 i 个结点，并用 e 返回）
    1. 传入 *头指针 \*L* 、*删除位置 i* 、*返回值 \*e*
    2. 判断删除位置是否合法，i 不能为 0
    3. 找到第被删除结点的位置
        1. 新建一个指针 p ，指向头结点
        2. 设置一个计数器，记录当前指向第几个结点，默认为 0（头结点记为 0）
        3. 遍历整个链表，直到找到被删除结点
        4. 如果遍历完链表，没有找到被删除结点，就说明删除位置超过了表长
    4. 把被删除结点的值赋给 e 
    5. 把被删除结点的前一个结点的 next 指向被删除结点的下一个结点
    6. 把被删除结点的下一个结点的 prior 指向被删除结点的前一个结点
    7. 是否被删除结点 p 的空间

5. *遍历打印循环双链表*
    1. 传入 *头结点 \*L*
    2. 新建一个指针 p ，指向头结点
    3. 遍历整个链表，同时输出结点的值