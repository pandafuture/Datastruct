# 栈

- **栈** 是只允许在一端插入或者删除的线性表。

- **栈顶** ：允许插入和删除的一端

- **栈底** ：不允许插入和删除的一端

- **空栈** ：空表

- **栈的特点** ：**后进先出（FIFO）**

- **栈的基本操作**
  - **初始化**
  - **销毁**
  - **进栈**
  - **出栈**
  - **读栈顶元素**
  - **判空**

- **栈的数学性质** ：n 个不同元素入栈时，出栈元素不同排列的个数为 **${1\over{n+1}}C^n_{2n}$** （卡特兰数）

- 栈有两种存储方式：**顺序存储结构** 和 **链式存储结构**

- 采用顺序存储的栈称为 **顺序栈**

- 采用链式存储的栈称为 **链栈**

- 顺序栈中还包括了 **共享栈**





# 顺序栈的实现
1. 首先定义 **栈的最大容量**
    ```
    #define MAX_SIZE 100  // 定义栈的最大容量
    ```

2. 定义 **顺序栈结构体**
   - 包括 **存放栈中元素的数组** 和 记录栈顶元素的数组下标的 **栈顶“指针”**
    ```
    // 顺序栈结构体
    struct SequenceStack {
        int data[MAX_SIZE];  // 存储栈元素的数组
        int top;  // 栈顶“指针” ，指向栈顶元素的数组下标
    };
    ```

3. **初始化**
   1. 传入 **栈名 &S**
   2. 把 **栈顶“指针”** 初始化为 **-1** ，表示空栈
    ```
    // 初始化
    void InitStack(SequenceStack &S) {
        S.top = -1;  // 栈顶“指针”初始化为 -1 ，表示空栈
    }
    ```

4. **判空**
   1. 传入 **栈名 S**
   2. 直接返回栈顶指针是否指向 -1
    ```
    // 判空
    bool Empty(SequenceStack S) {
        return S.top == -1;  // 直接返回栈顶“指针”是否为 -1
    }
    ```

5. **判满**
   1. 传入 **栈名 S**
   2. 直接返回栈顶指针是否为最大容量减一，若是，则栈满；若不是，则栈未满。
    ```
    // 判满
    bool Full(SequenceStack S) {
        return S.top == MAX_SIZE - 1;  // 直接返回栈顶“指针”是否为最大表长 - 1
    }
    ```

6. **入栈操作**
   1. 传入 **栈名 &S** 、**要入栈的元素 e**
   2. 先判断栈是否已满
   3. 先把栈顶“指针”加一后，再把元素 e 入栈
    ```
    // 入栈操作
    bool Push(SequenceStack &S, int e) {
        // 先判断栈是否已满
        if(Full(S)) {
            std::cout << "栈已满" << std::endl;
            return false;
        }

        S.data[++S.top] = e;  // 栈顶“指针”先加一，然后入栈
        return true;
    }
    ```

7. **出栈操作**
   1. 传入 **栈名 S** 、**返回值 &e**
   2. 先判断栈是否为空
   3. 然后读取栈顶元素的值，再把栈顶“指针”减一
    ```
    // 出栈操作
    bool Pop(SequenceStack &S, int &e) {
        // 先判断栈是否为空
        if(Empty(S)) {
            std::cout << "栈为空" << std::endl;
            return false;
        }

        e = S.data[S.top--];  // 读取出栈顶元素的值，然后指针减一
        return true;
    }
    ```

8. **读栈顶元素**
   1. 传入 **栈名 S** 、**返回值 &e**
   2. 先判断栈是否为空
   3. 获取栈顶元素的值
    ```
    // 读栈顶元素
    bool GetTop(SequenceStack S, int &e) {
        // 先判断栈是否为空
        if(Empty(S)) {
            std::cout << "栈为空" << std::endl;
            return false;
        }

        e = S.data[S.top];  // 获取栈顶元素的值
        return true;
    }
    ```

9. **输出栈**
   1.  传入 **栈名 S**
   2.  先判断栈是否为空
   3.  再从栈顶开始遍历整个栈，同时打印每个元素的值
    ```
    // 打印栈
    void PrintStack(SequenceStack S) {
        // 先判断栈是否为空
        if(Empty(S)) {
            std::cout << "栈为空" << std::endl;
            return;
        }

        // 从栈顶开始遍历整个栈，同时打印每个元素的值
        for (int i = S.top; i >= 0; i--) {
            std::cout << S.data[i] << " ";
        }
        std::cout << std::endl;
    }
    ```

10. **销毁操作**
    1. 对于静态数组实现的栈，只需要把栈顶指针重置就行
    ```
    // 销毁操作
    void DestroyStack(SequenceStack &S) {
        S.top = -1;  // 对于静态数组实现的栈，只需要重置栈顶指针
    }
    ```





# 共享栈的实现
1. 先定义共享栈的 **最大容量**
    ```
    #define MAX_SIZE 100  // 共享栈的总容量
    ```

2. 定义 **共享栈结构体**
    1. 先设置一个存储栈元素的 **数组**
    2. 再设置一个 **栈 1** 的 **栈顶“指针”**
    3. 再设置一个 **栈 2** 的 **栈顶“指针”**
    ```
    // 共享栈结构体
    struct SharedStack {
        int data[MAX_SIZE];  // 存储栈元素的数组
        int top1;  // 栈1 的栈顶“指针”
        int top2;  // 栈2 的栈顶“指针”
    };
    ```

3. **初始化**
   1. 传入 **栈名 &S**
   2. **初始化栈顶指针**
      1. 栈1 栈顶指针初始化为 -1 ，因为 栈1 的栈底为 0
      2. 栈2 栈顶指针初始化为 MAX_SIZE ，因为 栈2 的栈底为 MAX_SIZE
    ```
    // 初始化共享栈
    void InitSharedStack(SharedStack &S) {
        S.top1 = -1;  // 栈1 初始化为空（从数组左端开始）
        S.top2 = MAX_SIZE;  // 栈2 初始化为空（从数组右端开始）
    }
    ```

4. **判空**
   1. 栈1
      1. 传入 **栈名 S**
      2. 直接返回栈1的栈顶指针是否指向 -1
        ```
        // 判空
        bool Empty1(SharedStack S) {
            return S.top1 == -1;  // 直接返回栈1的栈顶指针是否为 -1
        }
        ```
   2. 栈2
      1. 传入 **栈名 S**
      2. 直接返回栈2的栈顶指针是否指向 MAX_SIZE
        ```
        bool Empty2(SharedStack S) {
            return S.top2 == MAX_SIZE;  // 直接返回栈2的栈顶指针是否为初始值
        }        
        ```

5. **判满**
   1. 传入 **栈名 S**
   2. 看两个栈顶指针是否相邻，如果相邻就说明栈满，不相邻，则栈未满
    ```
    // 判满
    bool Full(SharedStack S) {
        return S.top1 + 1 == S.top2;  // 两个栈顶相邻表示栈满
    }
    ```

6. **入栈**
   1. 栈1
      1. 传入 **栈名 &S** 、**要入栈的元素 e**
      2. 先判断栈是否已满
      3. 未满则把 **栈顶指针先加一** ，再把元素入栈
        ```
        bool Push1(SharedStack &S, int e) {
            // 先判断栈是否已满
            if(Full(S)) {
                std::cout << "栈已满";
                return false;
            }

            S.data[++S.top1] = e;  // 栈1 栈顶“指针”先加一，再入栈
            return true;
        }
        ```
    2. 栈2
       1. 传入 **栈名 &S** 、**要入栈的元素 e**
       2. 先判断栈是否已满
       3. 未满则先把 **栈顶指针减一** ，再把元素入栈
        ```
        bool Push2(SharedStack &S, int e) {
            // 先判断栈是否已满
            if(Full(S)) {
                std::cout << "栈已满";
                return false;
            }

            S.data[--S.top2] = e;  // 栈2 栈顶“指针”先减一，在入栈
            return true;
        }
        ```

7. **出栈**
   1. 栈1
      1. 传入 **栈名 &S** 、**返回值 &e**
      2. 先判断栈1是否为空
      3. 先读取栈顶元素，然后把栈顶指针减一
        ```
        bool Pop1(SharedStack &S, int &e) {
            // 先判断栈1是否为空
            if(Empty1(S)) {
                std::cout << "栈1为空";
                return false;
            }

            e = S.data[S.top1--];  // 读取栈顶元素值，再把栈1栈顶“指针”减一
            return true;
        }
        ```
    2. 栈2
       1. 传入 **栈名 &S** 、**返回值 &e**
       2. 先判断栈2是否为空
       3. 读取栈顶元素，再把栈顶指针加一
        ```
        bool Pop2(SharedStack &S, int &e) {
            // 先判断栈2是否为空
            if(Empty2(S)) {
                std::cout << "栈2为空";
                return false;
            }

            e = S.data[S.top2++];  // 读取栈2栈顶元素值，再把栈2栈顶“指针”加一
            return true;
        }
        ```

8. **读栈顶元素**
   1. 栈1
      1. 传入 **栈名 S** 、**返回值 &e**
      2. 先判断栈1是否为空
      3. 读取栈顶元素
        ```
        // 读栈顶元素
        bool GetTop1(SharedStack S, int &e) {
            // 先判断栈1是否为空
            if(Empty1(S)) {
                std::cout << "栈1为空";
                return false;
            }

            e = S.data[S.top1];  // 读取栈1的栈顶元素
            return true;
        }
        ```
    2. 栈2
       1. 传入 **栈名 S** 、**返回值 &e**
       2. 先判断栈2是否为空
       3. 读取栈2的栈顶元素
        ```
        bool GetTop2(SharedStack S, int &e) {
            // 先判断栈2是否为空
            if(Empty2(S)) {
                std::cout << "栈2为空";
                return false;
            }

            e = S.data[S.top2];  // 读取栈2的栈顶元素
            return true;
        }
        ```

9. **输出栈**
   1.  传入 **栈名 S**
   2.  先判断栈1是否为空，若不为空，则从栈顶开始遍历整个栈1，同时输出每个元素
   3.  再判断栈2是否为空，若不为空，则从栈顶开始遍历整个栈2，同时输出每个元素
    ```
    // 输出栈
    void PrintSharedStack(SharedStack S) {
        std::cout << "输出栈1: ";
        // 先判断栈 1 是否为空
        if(Empty1(S)) {
            std::cout << "栈1为空";
        }
        else {
            // 不为空，则从栈1的栈顶开始遍历整个栈1，同时输出元素
            for (int i = S.top1; i >= 0; i--) {
                std::cout << S.data[i] << " ";
            }
        }
        std::cout << std::endl;

        std::cout << "输出栈2: ";
        // 先判断栈2 是否为空
        if(Empty2(S)) {
            std::cout << "栈2为空";
        }
        else {
            // 不为空，则从栈2的栈顶开始遍历整个栈2，同时输出元素
            for (int i = S.top2; i < MAX_SIZE; i++) {
                std::cout << S.data[i] << " ";
            }
        }
        std::cout << std::endl;
    }
    ```

10. **求栈长**
    1.  栈1
        1.  传入 **栈名 S**
        2.  直接返回指针值加一
        ```
        int Length1(SharedStack S) {
            return S.top1 + 1;
        }        
        ```
    2. 栈2
       1. 传入 **栈名 S**
       2. 直接返回最大表长减栈顶指针值
        ```
        int Length2(SharedStack S) {
            return MAX_SIZE - S.top2;
        }
        ```

11. **销毁操作**
    1.  传入 **栈名 &S**
    2.  重置栈1的栈顶指针为 -1
    3.  重置栈2的栈顶指针为 MAX_SIZE
    ```
    // 销毁栈
    void DestroySharedStack(SharedStack &S) {
        S.top1 = -1;  // 重置栈1
        S.top2 = MAX_SIZE;  // 重置栈2
    }
    ```





# 链栈的实现
## 链栈（不带头结点）的实现
1. 首先定义不带头结点的链栈 **存储结构** 。包括 **数据域** 和 **指针域**
    ```
    // 不带头结点的链栈存储结构
    struct LSNode {
        int data;  // 数据域
        LSNode *next;  // 指针域
    };
    ```

2. **初始化**
   1. 传入 **头指针 \*&S**
   2. 把头指针指向空
    ```
    // 初始化链栈
    void InitStack(LSNode *&S) {
        S = nullptr;  // 不带头结点，就把头指针指向空
    }
    ```

3. **判空**
   1. 传入 **头指针 \*S**
   2. 直接返回头指针是否指向空，如果指向空，则链栈为空，如果不指向空，则链栈不为空
    ```
    // 判空操作
    bool Empty(LSNode *S) {
        return S == nullptr;  // 直接返回头指针是否为空
    }
    ```

4. **入栈**
   1. 传入 **头指针 \*&S** 、**要入栈的元素 e**
   2. 创建一个新结点 w
   3. 把 e 的值赋给新节点 w
   4. 把新结点 w 的 next 指针指向头指针指向的第一个结点
   5. 把头指针指向新结点
    ```
    // 入栈操作
    bool Push(LSNode *&S, int e) {
        LSNode *w = new LSNode;  // 创建一个新结点 w
        w -> data = e;  // 把 e 的值赋给新结点 w
        w -> next = S;  // 把新结点 w 的 next 指向头指针指向的当前第一个结点
        S = w;  // 把头指针指向 w

        return true;
    }
    ```

5. **出栈**
    1. 传入 **头指针 \*&S** 、**返回值 &e**
    2. 先判断栈是否为空
    3. 新建一个指针 p ，指向栈顶元素
    4. 用 e 返回栈顶元素的值
    5. 把栈顶指针指向第二元素
    6. 删除栈顶元素
    ```
    // 出栈操作
    bool Pop(LSNode *&S, int &e) {
        // 先判断栈是否为空
        if(Empty(S)) {
            std::cout << "栈为空" << std::endl;
            return false;
        }

        LSNode *p = S;  // 新建一个指针 p ，指向栈顶元素
        e = p -> data;  // 用 e 返回出栈元素的值
        S = S -> next;  // 把栈顶指针指向第二个元素
        delete p;  // 删除栈顶元素

        return true;
    }
    ```

6. **读栈顶元素**
   1. 传入 **头指针 \*S** 、**返回值 &e**
   2. 先判断栈是否为空
   3. 用 e 记录栈顶元素
    ```
    // 读栈顶元素
    bool GetTop(LSNode *S, int &e) {
        // 先判断栈是否为空
        if(Empty(S)) {
            std::cout << "栈为空" << std::endl;
            return false;
        }

        e = S -> data;  // e 记录栈顶元素
        return true;
    }
    ```

7. **输出栈**
   1. 传入 **头指针 \*S**
   2. 先判断栈是否为空
   3. 新建一个指针 p ，指向第一个元素
   4. 遍历整个栈，同时输出每个元素
    ```
    // 输出栈
    void PrintStack(LSNode *S) {
        // 先判断栈是否为空
        if(Empty(S)) {
            std::cout << "栈为空" << std::endl;
            return;
        }

        LSNode *p = S;  // 新建一个指针 p ，指向栈顶元素
        while(p) {
            std::cout << p -> data << " ";  // 打印当前结点的值
            p = p -> next;
        }
        std::cout << std::endl;
    }
    ```

8. **销毁栈**
   1. 传入 **头指针 \*&S**
   2. 设置一个返回值 e 
   3. 弹出所有元素，直到栈为空
    ```
    // 销毁栈
    void DestroyStack(LSNode *&S) {
        int e;
        // 循环弹出所有元素
        while(!Empty(S)) {
            Pop(S, e);
        }
    }
    ```




## 链栈（带头结点）的实现
1. 先定义链栈（带头结点）的 **存储结构** 。包括 **数据域** 和 **指针域**
    ```
    // 链栈（带头结点）存储结构
    struct LSNode {
        int data;  // 数据域
        LSNode *next;  // LSNode 类型的指针域，指向下一个结点
    };
    ```

2. **初始化**
   1. 传入 **头指针 \*&S**
   2. 创建一个头结点
   3. 把头结点的 next 指向空
    ```
    // 初始化链栈
    void InitStack(LSNode *&S) {
        S = new LSNode;  // 创建一个头结点
        S -> next = nullptr;  // 头结点的 next 设为空
    }
    ```

3. **判空**
   1. 传入 **头指针 \*S**
   2. 看头结点的指针是否指向空，如果指向空，则链表为空，若不指向空，则链表不为空
    ```
    // 判空
    bool Empty(LSNode *S) {
        return S -> next == nullptr;  // 看头结点的 next 是否为空
    }
    ```

4. **入栈**
   1. 传入 **头指针 \*&S** 、**要入栈的元素 e**
   2. 新建一个结点 w
   3. 把 e 的值赋给新结点 w
   4. 把新结点 w 的 next 指向当前的栈顶元素（不是头结点）
   5. 把头结点的 next 指向新结点 w
    ```
    // 入栈操作
    void Push(LSNode *&S, int e) {
        LSNode *w = new LSNode;  // 新建一个结点
        w -> data = e;  // 把 e 的值赋给 w
        w -> next = S -> next;  // 把新结点的 next 指向头结点的 next
        S -> next = w;  // 把头结点的 next 指向新结点 w
    }
    ```

5. **出栈**
   1. 传入 **头指针 \*&S** 、**返回值 &e**
   2. 先判断链栈是否为空
   3. 新建一个指针 p ，指向栈顶元素
   4. 用 e 返回栈顶元素的值
   5. 把头结点的 next 指向栈顶元素的后继结点
   6. 删除栈顶元素 p
    ```
    // 出栈操作
    bool Pop(LSNode *&S, int &e) {
        // 先判断栈是否为空
        if(Empty(S)) {
            std::cout << "栈为空" << std::endl;
            return false;
        }

        LSNode *p = S -> next;  // 新建一个指针 p ，指向第一个结点
        e = p -> data;  // 用 e 返回栈顶元素的值
        S -> next = p -> next;  // 把头结点的 next 指向栈顶元素的下一个元素
        delete p;  // 删除栈顶元素
        return true;
    }
    ```

6. **读栈顶元素**
   1. 传入 **头指针 \*S** 、**返回值 &e**
   2. 先判断链栈是否为空
   3. 用 e 返回栈顶元素的值
    ```
    // 读栈顶元素
    bool GetTop(LSNode *S, int &e) {
        // 先判断栈是否为空
        if(Empty(S)) {
            std::cout << "栈为空" << std::endl;
            return false;
        }

        e = S -> next -> data;  // 用 e 返回栈顶元素的值
        return true;
    }
    ```

7. **输出栈**
   1. 传入 **头指针 \*S**
   2. 先判断链栈是否为空
   3. 新建一个指针 p ，指向栈顶
   4. 遍历整个链栈，同时输出每个元素
    ```
    // 输出栈
    void PrintStack(LSNode *S) {
        // 先判断栈是否为空
        if(Empty(S)) {
            std::cout << "栈为空" << std::endl;
            return;
        }

        LSNode *p = S -> next;  // 新建一个指针 p ，指向栈顶元素
        while(p) {
            std::cout << p -> data << " ";  // 打印当前结点的数据域
            p = p -> next;
        }
        std::cout << std::endl;
    }
    ```

8. **销毁栈**
   1. 传入 **头指针 \*&S**
   2. 设置一个返回值 e
   3. 循环弹出所有元素，直到栈为空
    ```
    // 销毁栈
    void DestroyStack(LSNode *&S) {
        int e;
        // 循环弹出所有元素
        while(!Empty(S)) {
            Pop(S, e);
        }
    }
    ```





# 栈的应用
## 栈在括号匹配中的应用
用顺序栈实现括号匹配。


1. 先定义顺序栈的 **最大容量**
   ```
    #define MAX_SIZE 100  // 定义顺序栈的最大容量
   ```

2. 然后实现栈的 **基本操作**
   - **顺序栈结构体** 。包括用来存放括号的 **字符类型的数组** 和 **栈顶指针**
        ```
        // 顺序栈结构体
        struct SqStack {
            char data[MAX_SIZE];  // 静态数组存放栈中元素
            int top;  // 栈顶“指针”，指向栈顶元素的数组下标
        };
        ```
   - **初始化**
        ```
        // 初始化栈
        void InitStack(SqStack &S) {
            S.top = -1;  // 栈顶“指针”初始化为 -1，表示空栈
        }
        ```
   - **判空**
        ```
        // 判空
        bool Empty(SqStack S) {
            return S.top == -1;  // 直接返回栈顶“指针”是否为空
        }
        ```
   - **判满**
        ```
        // 判满
        bool Full(SqStack S) {
            return S.top == MAX_SIZE - 1;  // 直接返回栈顶指针是否为最大表长 - 1
        }
        ```
   - **入栈**
        ```
        // 入栈
        bool Push(SqStack &S, char e) {
            // 先判断栈是否已满
            if(Full(S)) {
                std::cout << "栈已满" << std::endl;
                return false;
            }

            S.data[++S.top] = e;  // 栈顶指针加一，然后入栈
            return true;
        }
        ```
   - **出栈**
        ```
        // 出栈
        bool Pop(SqStack &S, char &e) {
            // 先判断栈是否为空
            if(Empty(S)) {
                std::cout << "栈为空" << std::endl;
                return false;
            }

            e = S.data[S.top--];  // 读出栈顶元素的值，然后指针减一
            return true;
        }
        ```

3. 实现 **括号匹配算法**
   - 先声明一个栈 S
   - 初始化栈 S
   - 遍历每个字符，把左括号入栈，把右括号进行匹配
   - 如果是左括号，就先检查栈是否已满，若未满，则入栈
   - 如果是右括号，就先检查栈中是否还有左括号，若没有，则匹配失败，如果有就弹出栈顶的括号，检查是否匹配，不匹配则匹配失败
   - 当所有字符遍历完成后，返回栈中是否还有左括号，如果还有就说明匹配失败，如果没有就说明匹配成功
        ```
        // 括号匹配算法
        bool bracketCheck(char str[], int length) {
            SqStack S;  // 声明一个栈
            
            InitStack(S);  // 初始化栈

            // 遍历每个字符，把左括号入栈，如果是右括号就查看是否匹配
            for(int i=0; i < length; i++) {
                if(str[i] == '(' || str[i] == '[' || str[i] == '{') {
                    if(Full(S)) {
                        std::cout << "栈已满" << std::endl;
                        return false;
                    }
                    Push(S, str[i]);
                }
                else {
                    // 如果扫描到的是右括号，且当前栈为空，则匹配失败
                    if(Empty(S)) {
                        std::cout << "匹配失败";
                        return false;
                    }

                    char topChar;  // 栈顶元素
                    Pop(S, topChar);  // 弹出栈顶元素
                    // 进行括号匹配
                    if(str[i] == ')' && topChar != '(') {
                        std::cout << "匹配失败";
                        return false;
                    }
                    if(str[i] == ']' && topChar != '[') {
                        std::cout << "匹配失败";
                        return false;
                    }
                    if(str[i] == '}' && topChar != '{') {
                        std::cout << "匹配失败";
                        return false;
                    }
                }
            }

            return Empty(S);  // 检查栈是否为空，栈空说明匹配成功
        }
        ```

 


## 栈在表达式求值中的应用
- **算术表达式三要素** ：**运算符** 、**操作数** 、**界限符**
- **中缀表达式** ：运算符在两个操作数中间
- **后缀表达式** ：运算符在两个操作数后面
- **前缀表达式** ：运算符在两个操作数前面

- **中缀表达式转后缀表达式** 最好遵循 **“左优先”原则** ，即只要左边的运算符能先计算，就优先算左边的

- **后缀表达式求值** ：从左往右扫描，每遇到一个运算符，就让运算符前面最近的两个操作数执行相应运算，合体为一个操作数。

- **中缀表达式转前缀表达式** 最好遵循 **“右优先”原则** ，即只要右边的运算符能先计算，就优先算右边的

- **前缀表达式求值** ：从右往左扫描，每遇到一个运算符，就让运算符前面最近的两个操作数执行相应运算，合体为一个操作数


### 中缀表达式转后缀表达式的实现
1. 定义顺序栈的 **最大容量**
    ```
    #define MAX_SIZE 100  // 顺序栈的最大容量
    ```

2. 实现栈的 **基本操作**
   - 定义字符类型的 **顺序栈结构体** ，用于保存暂时还不能确定运算顺序的运算符。包括用来存储运算符的 **数组** ，**栈顶指针**
       ```
       // 顺序栈结构体（字符类型）
       // 用于保存暂时还不能确定运算顺序的运算符
       struct CharStack {
           char data[MAX_SIZE];  // 存储字符的数组
           int top;  // 栈顶指针
       };
       ```

    - **初始化**
        ```
        // 初始化栈
        void InitStack(CharStack &S) {
            S.top = -1;  // 把栈顶指针初始化为 -1 ，表示空栈
        }
        ```

    - **判空**
        ```
        // 判空
        bool Empty(CharStack S) {
            return S.top == -1;  // 看栈顶指针是否指向 -1
        }
        ```

    - **判满**
        ```
        // 判满
        bool Full(CharStack S) {
            return S.top == MAX_SIZE - 1;
        }
        ```

    - **入栈**
        ```
        // 入栈
        bool Push(CharStack &S, char e) {
            // 先判断栈是否已满
            if(Full(S)) {
                std::cout << "栈已满" << std::endl;
                return false;
            }

            S.data[++S.top] = e;  // 先把栈顶指针加一，在入栈
            return true;
        }
        ```

    - **出栈**
        ```
        // 出栈
        bool Pop(CharStack &S, char &e) {
            // 先判断栈是否为空
            if(Empty(S)) {
                std::cout << "栈为空" << std::endl;
                return false;
            }

            e = S.data[S.top--];  // 先出栈，然后把栈顶指针减一
            return true;
        }
        ```

    - **读栈顶元素**
        ```
        // 读栈顶元素
        bool GetTop(CharStack S, char &e) {
            // 先判断栈是否为空
            if(Empty(S)) {
                std::cout << "栈为空" << std::endl;
                return false;
            }

            e = S.data[S.top];  // 用 e 返回栈顶元素
            return true;
        }
        ```

3. **获取运算符优先级** ，用于运算符优先级比较。
    - 加号和减号的优先级为 1
    - 乘号和除号的优先级为 2
    - 其他运算符的优先级为 0
    ```
    // 获取运算符优先级
    int GetPriority(char op) {
        // 加号和减号的优先级为 1
        if(op == '+' || op == '-')
            return 1;
        
        // 乘号和除号优先级为 2
        if(op == '*' || op == '/')
            return 2;

        // 其他运算符优先级为 0
        return 0;
    }
    ```

4. **中缀表达式转后缀表达式算法**
   1. 传入 **中缀表达式**
   2. **声明** 并 **初始化** 一个 **顺序栈 S**，用于保存暂时不能确定运算顺序的运算符
   3. 再创建一个 **字符串 postfix** 用来存储转换后的 **后缀表达式**
   4. 从左到右处理中缀表达式中的各个元素，直到末尾
      1. 当遇到 **空格** 时，跳过空格
      2. 当遇到 **操作数** 时，提取整个数字（整数、小数、多位数），并加入后缀表达式，然后在数字后面加空格以便输出查看。最后退回一个字符，负责循环结束时，i 指向的是数字后面的第一个非数字字符
      3. 当遇到 **左括号** 时，把左括号入栈
      4. 当遇到 **右括号** 时，则依次弹出栈内运算符并加入后缀表达式，直到弹出左括号为止。
         - **注意** ：界限符不加入后缀表达式
      5. 当遇到 **运算符** 时，依次弹出栈中优先级高于或等于当前运算符的所有运算符，并加入后缀表达式。如果碰到左括号或栈空则停止。最后把当前运算符入栈。
   5. 遍历完中缀表达式中的所有字符后，将栈中剩余运算符依次弹出，并加入后缀表达式。
   6. 对得到的后缀表达式进行美化，即删除最后一个空格
    ```
    // 中缀表达式转后缀表达式
    std::string InfixToPostfix(const std::string &infix) {
        CharStack S;  // 声明一个栈
        InitStack(S);  // 初始化栈
        std::string postfix = "";  // 用来存储转换后的后缀表达式

        for(int i = 0; i < infix.length(); i++) {
            char c = infix[i];

            // 跳过空格
            if(c == ' ') 
                continue;

            // 处理操作数（包括多位数）
            if(std::isdigit(c)) {
                // 提取整个数字
                while(i < infix.length() && (std::isdigit(infix[i]) || infix[i] == '.')) {
                    postfix += infix[i++];  // 将当前字符添加到后缀表达式
                }
                postfix += ' ';  // 数字后面加空格分割
                i--;  // 回退一个字符，否则循环结束时，i 指向的是数字后的第一个非数字字符
                continue;
            }

            // 处理左括号
            if(c == '(') {
                Push(S, c);  // 把左括号入栈
                continue;
            }

            // 处理右括号
            if(c == ')') {
                char topChar;  // 用于返回栈顶元素

                // 遇到 ')' 则一次弹出栈内运算符并加入后缀表达式，直到弹出 '(' 为止
                while(GetTop(S, topChar) && topChar != '(') {
                    Pop(S, topChar);
                    postfix += topChar;
                    postfix += ' ';
                }
                Pop(S, topChar);  // 弹出左括号
                continue;
            }

            // 处理运算符
            char topChar;  // 用于返回栈顶元素

            // 依次弹出栈中优先级高于或等于当前运算符的所有运算符，并加入后缀表达式
            // 若碰到 '(' 或栈空则停止
            while(GetTop(S, topChar) && topChar != '(' && GetPriority(c) <= GetPriority(topChar)) {
                Pop(S, topChar);
                postfix += topChar;
                postfix += ' ';
            }
            Push(S, c);  // 最后把当前运算符入栈
        }

        // 弹出栈中剩余运算符
        char topChar;
        while(Pop(S, topChar)) {
            postfix += topChar;  // 把剩余运算符加入到后缀表达式中
            postfix += ' ';  // 每个运算符后加空格
        }

        // 删除最后一空格（如果有）
        if(!postfix.empty() && postfix.back() == ' ') {
            postfix.pop_back();
        }

        return postfix;  // 返回最终的后缀表达式
    }
    ```



### 后缀表达式求值的实现
1. 首先定义顺序栈 **最大容量**
    ```
    #define MAX_SIZE 100  // 定义顺序栈最大容量
    ```

2. 实现顺序栈的 **基本操作**
    - **顺序栈结构体** ，用来存放操作数。包括存储操作数的 **数组** 和 **栈顶指针**
        ```
        // 顺序栈结构体，用来存放操作数
        struct NumStack {
            double data[MAX_SIZE];  // 存储操作数的数组
            int top;  // 栈顶指针
        };
        ```
    - **初始化**
        ```
        // 初始化
        void InitStack(NumStack &S) {
            S.top = -1;  // 栈顶指针初始化为 -1，表示空栈
        }
        ```
    - **判空**
        ```
        // 判空
        bool Empty(NumStack S) {
            return S.top == -1;
        }
        ```
    - **判满**
        ```
        // 判满
        bool Full(NumStack S) {
            return S.top == MAX_SIZE - 1;
        }
        ```
    - **操作数入栈**
        ```
        // 操作数入栈
        bool PushNum(NumStack &S, double e) {
            // 先判断栈是否已满
            if(Full(S)) {
                std::cout << "操作数栈已满" << std::endl;
                return false;
            }

            S.data[++S.top] = e;  // 先把指针加一，再入栈
            return true;
        }
        ```
    - **操作数出栈**
        ```
        // 操作数出栈
        bool PopNum(NumStack &S, double &e) {
            // 先判断栈是否为空
            if(Empty(S)) {
                std::cout << "操作数栈为空" << std::endl;
                return false;
            }

            e = S.data[S.top--];  // 先出栈，再把指针减一
            return true;
        }
        ```

3. **基本运算方法**
   1. 传入 **操作数 a** 、**操作数 b** 、**运算符 op**
   2. 如果操作符是加号，就执行加法操作
   3. 如果操作符是减号，就执行减法操作
   4. 如果操作符是乘号，就执行乘法操作
   5. 如果操作符是除号，就先判断被除数是否为 0 ，若为 0 ，则返回错误信息，若不为 0 ，则执行除法操作
   6. 如果是其他操作符，就返回错误提示
    ```
    // 执行运算
    double calculate(double a, double b, char op) {
        switch(op) {
            // 如果是加号，就执行加法操作
            case '+': return a + b;

            // 如果是减号，就执行减法操作
            case '-': return a - b;

            // 如果是乘号，就执行乘法操作
            case '*': return a * b;

            // 如果是除号，就执行除法操作。注意被除数不能为 0
            case '/':
                if(b == 0) {
                    std::cerr << "错误：被除数不能为 0" << std::endl;
                    exit(EXIT_FAILURE);
                }
                return a / b;
            // 如果是其他操作符，则返回错误提示
            default:
                std::cerr << "错误：非法操作符" << std::endl;
                exit(EXIT_FAILURE);
        }
    }
    ```

4. **后缀表达式求值算法**
   1. 传入 **后缀表达式**
   2. **声明** 并 **初始化** 一个顺序栈，用来存放操作数
   3. 创建一个 **字符串出入流对象 iss** ，把 postfix 字符串包装成输入流，允许使用 >> 来按照空格分割字符串。但需要引用 <sstream> 头文件
   4. 再声明一个 **字符串变量** ，用于存储输入流中提取的每个元素
   5. 从左往右扫描元素，直到处理完所有元素
      1. 如果是 **操作数** ，就转换成双精度浮点型压入栈中
      2. 如果是 **运算符** ，就弹出两个栈顶元素，执行相应的计算，再把运算结果压入栈中
   6. 遍历完所有元素后检查栈中是否只有一个元素，即最终结果，如果还有其他元素就说明表达式不完整。
   7. 把最终结果从栈顶弹出，并用 finalResult 返回
    ```
    // 后缀表达式求值算法
    double EvaluationPostfix(const std::string &postfix) {
        NumStack S;  // 声明一个顺序栈
        InitStack(S);  // 初始化栈


        // 创建一个字符串输入流对象 iss ，把 postfix 字符串包装成输入流，允许使用 ">>" 来按空格分割字符串
        // 需要引用 <sstream> 头文件
        std::istringstream iss(postfix);
        // 声明一个字符串变量，用于存储从输入流中提取的每个元素
        std::string token;

        while(iss >> token) {
            // 如果是操作数
            if(isdigit(token[0])) {
                try {
                    // 用 std::stod 将字符串转换成双精度浮点数
                    double num = std::stod(token);
                    PushNum(S, num);
                }
                catch(...) {
                    // 捕获任何类型的异常
                    // 任何创建一个新的 std::runtime_error 类型的异常，包含错误信息
                    // 抛出这个异常
                    throw std::runtime_error("错误：无效的操作数 " + token);
                }
            }
            // 如果是运算符
            else {
                double b, a;  // 存储操作数
                // 先弹出操作数 b
                if(!PopNum(S, b)) {
                    // 抛出异常
                    throw std::runtime_error("错误：缺少操作数");
                }
                // 再弹出操作数 a
                if(!PopNum(S, a)) {
                    // 抛出异常
                    throw std::runtime_error("错误：缺少操作数");
                }

                try {
                    // 进行相应计算
                    double result = calculate(a, b, token[0]);
                    // 把计算结果压入栈中
                    PushNum(S, result);
                }
                catch(const std::runtime_error& e) {
                    throw;  // 重新抛出异常
                }
            }
        }

        // 检查最终栈中的元素数量
        if(S.top != 0) {
            throw std::runtime_error("错误：表达式不完整");
        }

        double finalResult;  // 存储最终计算结果
        PopNum(S, finalResult);  // 把最终结果弹出，用 finalResult 返回
        return finalResult;  // 返回最终结果
    }
    ```



### 中缀表达式求值的实现
1. 先定义顺序栈 **最大容量**
    ```
    #define MAX_SIZE 100  // 定义顺序栈最大容量
    ```

2. 实现顺序栈的 **基本操作**
    - **操作数栈结构体** 包括存储操作数的 **数组** 和 **栈顶指针**
        ```
        // 定义操作数栈结构体（存储整数）
        struct NumStack {
            int data[MAX_SIZE];  // 存储操作数的数组
            int top;  // 栈顶指针
        };
        ```
    - **运算符栈结构体** 包括存储运算符的 **数组** 和 **栈顶指针**
        ```
        // 定义运算符栈结构体（存储字符）
        struct OpStack {
            char data[MAX_SIZE];  // 存储运算符的数组
            int top;  // 栈顶指针
        };
        ```
    - **初始化操作数栈**
        ```
        // 初始化操作数栈
        void InitNumStack(NumStack &S) {
            S.top = -1;  // 栈顶指针初始化为 -1 ，表示空栈
        }
        ```
    - **初始化运算符栈**
        ```
        // 初始化运算符栈
        void InitOpStack(OpStack &S) {
            S.top = -1;  // 栈顶指针初始化为 -1 ，表示空栈
        }
        ```
    - **判空操作数栈**
        ```
        // 判空操作数栈
        bool EmptyNumStack(NumStack S) {
            return S.top == -1;  // 看栈顶指针是否等于 -1
        }
        ```
    - **判空运算符栈**
        ```
        // 判空运算符栈
        bool EmptyOpStack(OpStack S) {
            return S.top == -1;  // 看栈顶指针是否等于 -1
        }
        ```
    - **判满操作数栈**
        ```
        // 判满操作数栈
        bool FullNumStack(NumStack S) {
            return S.top == MAX_SIZE - 1;  // 看栈顶指针是否指向最大容量减一
        }
        ```
    - **判满运算符栈**
        ```
        // 判满运算符栈
        bool FullOpStack(OpStack S) {
            return S.top == MAX_SIZE - 1;  // 看栈顶指针是否指向最大容量减一
        }
        ```
    - **操作数入栈**
        ```
        // 操作数入栈
        bool PushNum(NumStack &S, int e) {
            // 先判断栈是否已满
            if(FullNumStack(S)) {
                std::cout << "操作数栈已满" << std::endl;
                return false;
            }

            S.data[++S.top] = e;  // 栈顶指针先加一，再入栈
            return true;
        }
        ```
    - **运算符入栈**
        ```
        // 运算符入栈
        bool PushOp(OpStack &S, char e) {
            // 先判断栈是否已满
            if(FullOpStack(S)) {
                std::cout << "运算符栈已满" << std::endl;
                return false;
            }

            S.data[++S.top] = e;  // 栈顶指针先加一，再入栈
            return true;
        }
        ```
    - **操作数出栈**
        ```
        // 操作数出栈
        bool PopNum(NumStack &S, int &e) {
            // 先判断操作数栈是否为空
            if(EmptyNumStack(S)) {
                std::cout << "操作数栈为空" << std::endl;
                return false;
            }

            e = S.data[S.top--];  // 先出栈，再把栈顶指针减一
            return true;
        }
        ```
    - **运算符出栈**
        ```
        // 运算符出栈
        bool PopOp(OpStack &S, char &e) {
            // 先判断操作数栈是否为空
            if(EmptyOpStack(S)) {
                std::cout << "运算符栈为空" <<std::endl;
                return false;
            }

            e = S.data[S.top--];  // 先出栈，再把栈顶指针减一
            return true;
        }
        ```
    - **读操作数栈栈顶元素**
        ```
        // 读操作数栈栈顶元素
        bool GetTopNum(NumStack S, int &e) {
            // 先判断操作数栈是否为空
            if(EmptyNumStack(S)) {
                std::cout << "操作数栈为空" << std::endl;
                return false;
            }

            e = S.data[S.top];  // 用 e 返回栈顶元素值
            return true;
        }
        ```
    - **读运算符栈栈顶元素**
        ```
        // 读运算符栈栈顶元素
        bool GetTopOp(OpStack S, char &e) {
            // 先判断运算符栈是否为空
            if(EmptyOpStack(S)) {
                std::cout << "运算符栈为空" <<std::endl;
                return false;
            }

            e = S.data[S.top];  // 用 e 返回栈顶元素值
            return true;
        }
        ```

3. **获取运算符优先级的方法**
   1. 传入 **要查看的运算符 op**
   2. **加号和减号** 的优先级设为 **1**
   3. **乘号和除号** 的优先级设为 **2**
   4. **其他符号** 的优先级设为 **0**
    ```
    // 获取运算符优先级
    int GetPriority(char op) {
        // 加号和减号优先级为 1
        if(op == '+' ||op == '-')
            return 1;

        // 乘号和除号优先级为 2
        if(op == '*' ||op == '/')
            return 2;

        // 其它符号优先级为 0
        return 0;
    }
    ```

4. **执行运算的方法**
   1. 传入 **两个操作数 a、b** 和 **一个运算符 op**
   2. 根据运算符执行相应的运算
      1. 如果是加号，就执行加法运算
      2. 如果是减号，就执行减法运算
      3. 如果是乘号，就执行乘法运算
      4. 如果是除号，就先判断被除数是否为 0 ，如果不为 0 ，就执行除法运算
      5. 如果是其他操作符，就退出
    ```
    // 执行运算
    int calculate(int a, int b, char op) {
        switch(op) {
            // 如果是加号，就执行加法运算
            case '+': return a + b;
            // 如果是减号，就执行减法运算
            case '-': return a - b;
            // 如果是乘号，就执行乘法运算
            case '*': return a * b;
            // 如果是除号，就先判断被除数是否为 0 ，不为 0 就执行除法运算
            case '/':
                if(b == 0) {
                    // std::cerr 专用于错误信息
                    std::cerr << "错误：被除数不能为 0" << std::endl;
                    // 立即终止程序执行
                    exit(EXIT_FAILURE);
                }
                return a / b;
            // 如果是其他操作符，就退出
            default:
                std::cerr << "错误：非法操作符" << std::endl;
                exit(EXIT_FAILURE);
        }
    }
    ```

5. **中缀表达式求值的算法**
   1. 传入 **要计算的中缀表达式**
   2. **声明** 并 **初始化** **操作数栈** 和 **运算符栈**
   3. 从左往右扫描中缀表达式，直到扫描完所有元素
      1. 遇到 **空格** ，则跳过空格
      2. 遇到 **操作数** ，就处理数字，并压入操作数栈中
      3. 遇到 **左括号** ，就把左括号压入栈中
      4. 遇到 **右括号** ，就计算括号内的表达式。
         1. 先弹出运算符栈栈顶元素
         2. 再弹出两个操作数栈栈顶元素
         3. 进行计算，再将计算结果压入操作数栈
         4. 重复这几步，直到运算符栈为空，或者遇到左括号
         5. 最后弹出左括号
      5. 遇到 **运算符** ，就先把运算符栈中优先级高于或等于当前运算符的所有运算符弹出，并弹出两个操作数，执行计算，把结果压入操作数栈中。直到碰到左括号或栈空停止。最后把当前运算符入栈
   4. 扫描完整个表达式后，依此处理栈中剩余运算符，直到运算符栈为空。
      1. 把操作数栈栈顶元素弹出
      2. 弹出两个操作数
      3. 执行相应计算
      4. 把结果入栈
   5. 把最终结果弹出，并返回最终结果
    ```
    // 中缀表达式求值函数
    int EvaluateExpression(std::string expr) {
        NumStack numStack;  // 声明操作数栈
        OpStack opStack;  // 声明运算符栈

        InitNumStack(numStack);  // 初始化操作符栈
        InitOpStack(opStack);  // 初始化操作符栈

        int i = 0;  // 作为计数器
        int length = expr.length();  // 获取字符串长度

        // 从左往右扫描中缀表达式，直到扫描完所有元素
        while(i < length) {
            // 跳过空格
            if(expr[i] == ' ') {
                i++;
                continue;
            }

            // 处理操作数
            if(std::isdigit(expr[i])) {
                int num = 0;  // 用来存储转换后的整数
                // 循环处理多位数字的情况
                while(i < length && std::isdigit(expr[i])) {
                    /*
                    先将已解析的数字左移一位
                    然后通过 ASCII 码值将后面的数字字符转为对应的整数值
                    最后构建完整的多位数整数
                    */
                    num = num * 10 + (expr[i] - '0');
                    i++;
                }
                PushNum(numStack, num);  // 将操作数压入操作数栈中
            }
            // 处理左括号
            else if(expr[i] == '(') {
                // 如果遇到左括号，就把左括号压入运算符栈中
                PushOp(opStack, expr[i]);
                i++;
            }
            // 处理右括号
            else if(expr[i] == ')') {
                // 如果遇到右括号，就计算括号内的表达式
                char op;
                while(GetTopOp(opStack, op) && op != '(') {
                    PopOp(opStack, op);  // 弹出运算符栈栈顶

                    int b, a;  // 存储操作数
                    PopNum(numStack, b);  // 弹出右操作数
                    PopNum(numStack, a);  // 弹出左操作数
                    int result = calculate(a, b, op);  // 计算
                    PushNum(numStack, result);  // 将计算结果压入操作数栈
                }
                PopOp(opStack, op);  // 弹出左括号
                i++;
            }
            // 处理运算符
            else {
                char currentOp = expr[i];  // 存储当前扫描到的运算符
                char topOp;  // 存储运算符栈的栈顶运算符

                // 先把运算符栈中优先级高于或等于当前运算符的所有运算符弹出，并弹出两个操作数，执行计算，运算结果再压入操作数栈
                // 直到碰到左括号或栈空则停止
                while(GetTopOp(opStack, topOp) && topOp != '(' && GetPriority(currentOp) <= GetPriority(topOp)) {
                    PopOp(opStack, topOp);  // 弹出栈顶运算符
                    int b, a;  // 存储操作数
                    PopNum(numStack, b);  // 弹出右操作数
                    PopNum(numStack, a);  // 弹出左操作数
                    int result = calculate(a, b, topOp);  // 计算
                    PushNum(numStack, result);  // 结果入栈
                }
                // 最后把当前运算符入栈
                PushOp(opStack, currentOp);
                i++;
            }
        }

        // 扫描完整个表达式后，依次处理栈中剩余运算符，直到运算符栈为空
        while(!EmptyOpStack(opStack)) {
            char op;
            PopOp(opStack, op);  // 把栈中栈顶运算符弹出
            int b, a;  // 存储操作数
            PopNum(numStack, b);  // 弹出右操作数
            PopNum(numStack, a);  // 弹出左操作数
            int result = calculate(a, b, op);  // 计算
            PushNum(numStack, result);  // 把结果入栈
        }

        // 返回最终结果
        int finalResult;
        PopNum(numStack, finalResult);  // 将最终结果出栈
        return finalResult;
    }
    ```