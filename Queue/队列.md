# 队列

- **队列** 是只允许在一端进行插入，在另一端删除的线性表。

- **队头（队首）** ：允许删除的一端

- **队尾** ：允许插入的一端

- **空队列** ：空表

- **队列的特点** ：**先进先出（FIFO）**

- **队列的基本操作**
  - **初始化队列**
  - **判队列空**
  - **入队**
  - **出队**
  - **读队首元素**
  - **销毁队列**

- 队列有两种存储方式：**顺序存储** 和 **链式存储**

- 采用顺序存储的队列称为 **顺序队列**

- 采用链式存储的队列称为 **链式队列**

- 把顺序队列从逻辑上是为一个环称为 **循环队列**





# 顺序队列（循环队列）的实现
1. 定义队列的 **最大容量**
    ```
    #define MAX_SIZE 50  // 定义队列的最大容量
    ```

2. 定义顺序队列（循环队列） **存储结构** 。包括存储队列元素的 **数组** 、指向队首元素的 **队首“指针” front** 、指向队尾元素的下一个位置的 **队尾“指针” rear**
    ```
    // 顺序队列（循环队列）存储结构
    struct SeqQueue {
        int data[MAX_SIZE];  // 存储队列元素的数组
        int front;  // 队首指针，指向队首元素
        int rear;  // 队尾指针，指向队尾元素的下一个位置
    };
    ```

3. **初始化队列**
   1. 传入 **队列名 &Q**
   2. 初始化队首“指针”为0
   3. 初始化队尾“指针”为0
    ```
    // 初始化队列
    void InitQueue(SeqQueue &Q) {
        Q.front = 0;  // 初始化队首指针为 0
        Q.rear = 0;  // 初始化队尾指针为 0
    }
    ```

4. **判空操作**
   1. 传入 **队列名 Q**
   2. 看队首“指针”是否与队尾“指针”相等。如果相等，则队列为空；如果不相等，则队列不为空
    ```
    // 判空操作
    bool Empty(SeqQueue Q) {
        return Q.front == Q.rear;
    }
    ```

5. **判满操作**
   1. 传入 **队列名 Q**
   2. 看队尾“指针”加一取模最大容量后是否等于队首“指针”，如果等于，则队列已满；如果不等于，则队列未满
    ```
    // 判满操作
    bool Full(SeqQueue Q) {
        return (Q.rear + 1) % MAX_SIZE == Q.front;  // 队尾下一个位置是队头时队列满
    }
    ```

6. **入队操作**
   1. 传入 **队列名 &Q** 、**入队元素 e**
   2. 先判断队列是否已满
   3. 把 e 入队到队尾指针指向的位置
   4. 把队尾指针加一取模最大容量
    ```
    // 入队操作
    bool EnQueue(SeqQueue &Q, int e) {
        // 先判断队列是否已满
        if(Full(Q)) {
            std::cout << "队列已满" << std::endl;
            return false;
        }

        Q.data[Q.rear] = e;  // 把 e 入队到队尾指针指向的位置
        Q.rear = (Q.rear + 1) % MAX_SIZE;  // 队尾指针加一取模
        return true;
    }
    ```

7. **出队操作**
   1. 传入 **队列名 &Q** 、**返回值 &e**
   2. 先判断队列是否为空
   3. 返回队首元素值
   4. 把队首指针后移一位
    ```
    // 出队操作
    bool DeQueue(SeqQueue &Q, int &e) {
        // 先判断队列是否为空
        if(Empty(Q)) {
            std::cout << "队列为空" << std::endl;
            return false;
        }

        e = Q.data[Q.front];  // 获取队首元素
        Q.front = (Q.front + 1) % MAX_SIZE;  // 队首指针后移一位
        return true;
    }
    ```

8. **读队首元素**
   1. 传入 **队列名 Q** 、**返回值 &e**
   2. 先判断队列是否为空
   3. 获取队首元素
    ```
    // 读队首元素
    bool GetHead(SeqQueue Q, int &e) {
        // 先判断队列是否为空
        if(Empty(Q)) {
            std::cout << "队列为空" << std::endl;
            return false;
        }

        e = Q.data[Q.front];  // 获取队首元素
        return true;
    }
    ```

9. **获取队列长度**
   1.  传入 **队列名 Q**
   2.  直接返回队尾指针值与队首指针值的插值加上最大容量后取模最大容量的结果
    ```
    // 获取队列长度
    int Length(SeqQueue Q) {
        return (Q.rear - Q.front + MAX_SIZE) % MAX_SIZE;
    }
    ```

10. **输出队列**
    1.  传入 **队列名 Q**
    2.  先判断队列是否为空
    3.  遍历整个循环队列，同时打印每个元素
    ```
    // 输出队列
    void PrintQueue(SeqQueue Q) {
        // 先判断队列是否为空
        if(Empty(Q)) {
            std::cout << "队列为空" << std::endl;
            return;
        }

        // 遍历整个循环队列，同时打印每个元素
        int i = Q.front;  // 从队首开始
        while(i != Q.rear) {
            std::cout << Q.data[i] << " ";
            i = (i + 1) % MAX_SIZE;
        }
        std::cout << std::endl;
    }
    ```

11. **销毁队列**
    1.  传入 **队列名 &Q**
    2.  对于静态数组，不需要释放内存，只需要重置队首指针和队尾指针
    ```
    // 销毁队列
    void DestroyQueue(SeqQueue &Q) {
        // 对于静态数组，不需要释放内存
        Q.front = 0;  // 重置队首指针
        Q.rear = 0;  // 重置队尾指针
    }
    ```