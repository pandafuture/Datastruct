# 栈

- **栈** 是只允许在一端插入或者删除的线性表。

- **栈顶** ：允许插入和删除的一端

- **栈底** ：不允许插入和删除的一端

- **空栈** ：空表

- **栈的特点** ：**后进先出（FIFO）**

- **栈的基本操作**
  - **初始化**
  - **销毁**
  - **进栈**
  - **出栈**
  - **读栈顶元素**
  - **判空**

- **栈的数学性质** ：n 个不同元素入栈时，出栈元素不同排列的个数为 **${1\over{n+1}}C^n_{2n}$** （卡特兰数）

- 栈有两种存储方式：**顺序存储结构** 和 **链式存储结构**

- 采用顺序存储的栈称为 **顺序栈**

- 采用链式存储的栈称为 **链栈**

- 顺序栈中还包括了 **共享栈**





# 顺序栈的实现
1. 首先定义 **栈的最大容量**
    ```
    #define MAX_SIZE 100  // 定义栈的最大容量
    ```

2. 定义 **顺序栈结构体**
   - 包括 **存放栈中元素的数组** 和 记录栈顶元素的数组下标的 **栈顶“指针”**
    ```
    // 顺序栈结构体
    struct SequenceStack {
        int data[MAX_SIZE];  // 存储栈元素的数组
        int top;  // 栈顶“指针” ，指向栈顶元素的数组下标
    };
    ```

3. **初始化**
   1. 传入 **栈名 &S**
   2. 把 **栈顶“指针”** 初始化为 **-1** ，表示空栈
    ```
    // 初始化
    void InitStack(SequenceStack &S) {
        S.top = -1;  // 栈顶“指针”初始化为 -1 ，表示空栈
    }
    ```

4. **判空**
   1. 传入 **栈名 S**
   2. 直接返回栈顶指针是否指向 -1
    ```
    // 判空
    bool Empty(SequenceStack S) {
        return S.top == -1;  // 直接返回栈顶“指针”是否为 -1
    }
    ```

5. **判满**
   1. 传入 **栈名 S**
   2. 直接返回栈顶指针是否为最大容量减一，若是，则栈满；若不是，则栈未满。
    ```
    // 判满
    bool Full(SequenceStack S) {
        return S.top == MAX_SIZE - 1;  // 直接返回栈顶“指针”是否为最大表长 - 1
    }
    ```

6. **入栈操作**
   1. 传入 **栈名 &S** 、**要入栈的元素 e**
   2. 先判断栈是否已满
   3. 先把栈顶“指针”加一后，再把元素 e 入栈
    ```
    // 入栈操作
    bool Push(SequenceStack &S, int e) {
        // 先判断栈是否已满
        if(Full(S)) {
            std::cout << "栈已满" << std::endl;
            return false;
        }

        S.data[++S.top] = e;  // 栈顶“指针”先加一，然后入栈
        return true;
    }
    ```

7. **出栈操作**
   1. 传入 **栈名 S** 、**返回值 &e**
   2. 先判断栈是否为空
   3. 然后读取栈顶元素的值，再把栈顶“指针”减一
    ```
    // 出栈操作
    bool Pop(SequenceStack &S, int &e) {
        // 先判断栈是否为空
        if(Empty(S)) {
            std::cout << "栈为空" << std::endl;
            return false;
        }

        e = S.data[S.top--];  // 读取出栈顶元素的值，然后指针减一
        return true;
    }
    ```

8. **读栈顶元素**
   1. 传入 **栈名 S** 、**返回值 &e**
   2. 先判断栈是否为空
   3. 获取栈顶元素的值
    ```
    // 读栈顶元素
    bool GetTop(SequenceStack S, int &e) {
        // 先判断栈是否为空
        if(Empty(S)) {
            std::cout << "栈为空" << std::endl;
            return false;
        }

        e = S.data[S.top];  // 获取栈顶元素的值
        return true;
    }
    ```

9. **输出栈**
   1.  传入 **栈名 S**
   2.  先判断栈是否为空
   3.  再从栈顶开始遍历整个栈，同时打印每个元素的值
    ```
    // 打印栈
    void PrintStack(SequenceStack S) {
        // 先判断栈是否为空
        if(Empty(S)) {
            std::cout << "栈为空" << std::endl;
            return;
        }

        // 从栈顶开始遍历整个栈，同时打印每个元素的值
        for (int i = S.top; i >= 0; i--) {
            std::cout << S.data[i] << " ";
        }
        std::cout << std::endl;
    }
    ```

10. **销毁操作**
    1. 对于静态数组实现的栈，只需要把栈顶指针重置就行
    ```
    // 销毁操作
    void DestroyStack(SequenceStack &S) {
        S.top = -1;  // 对于静态数组实现的栈，只需要重置栈顶指针
    }
    ```





# 共享栈的实现
1. 先定义共享栈的 **最大容量**
    ```
    #define MAX_SIZE 100  // 共享栈的总容量
    ```

2. 定义 **共享栈结构体**
    1. 先设置一个存储栈元素的 **数组**
    2. 再设置一个 **栈 1** 的 **栈顶“指针”**
    3. 再设置一个 **栈 2** 的 **栈顶“指针”**
    ```
    // 共享栈结构体
    struct SharedStack {
        int data[MAX_SIZE];  // 存储栈元素的数组
        int top1;  // 栈1 的栈顶“指针”
        int top2;  // 栈2 的栈顶“指针”
    };
    ```

3. **初始化**
   1. 传入 **栈名 &S**
   2. **初始化栈顶指针**
      1. 栈1 栈顶指针初始化为 -1 ，因为 栈1 的栈底为 0
      2. 栈2 栈顶指针初始化为 MAX_SIZE ，因为 栈2 的栈底为 MAX_SIZE
    ```
    // 初始化共享栈
    void InitSharedStack(SharedStack &S) {
        S.top1 = -1;  // 栈1 初始化为空（从数组左端开始）
        S.top2 = MAX_SIZE;  // 栈2 初始化为空（从数组右端开始）
    }
    ```

4. **判空**
   1. 栈1
      1. 传入 **栈名 S**
      2. 直接返回栈1的栈顶指针是否指向 -1
        ```
        // 判空
        bool Empty1(SharedStack S) {
            return S.top1 == -1;  // 直接返回栈1的栈顶指针是否为 -1
        }
        ```
   2. 栈2
      1. 传入 **栈名 S**
      2. 直接返回栈2的栈顶指针是否指向 MAX_SIZE
        ```
        bool Empty2(SharedStack S) {
            return S.top2 == MAX_SIZE;  // 直接返回栈2的栈顶指针是否为初始值
        }        
        ```

5. **判满**
   1. 传入 **栈名 S**
   2. 看两个栈顶指针是否相邻，如果相邻就说明栈满，不相邻，则栈未满
    ```
    // 判满
    bool Full(SharedStack S) {
        return S.top1 + 1 == S.top2;  // 两个栈顶相邻表示栈满
    }
    ```

6. **入栈**
   1. 栈1
      1. 传入 **栈名 &S** 、**要入栈的元素 e**
      2. 先判断栈是否已满
      3. 未满则把 **栈顶指针先加一** ，再把元素入栈
        ```
        bool Push1(SharedStack &S, int e) {
            // 先判断栈是否已满
            if(Full(S)) {
                std::cout << "栈已满";
                return false;
            }

            S.data[++S.top1] = e;  // 栈1 栈顶“指针”先加一，再入栈
            return true;
        }
        ```
    2. 栈2
       1. 传入 **栈名 &S** 、**要入栈的元素 e**
       2. 先判断栈是否已满
       3. 未满则先把 **栈顶指针减一** ，再把元素入栈
        ```
        bool Push2(SharedStack &S, int e) {
            // 先判断栈是否已满
            if(Full(S)) {
                std::cout << "栈已满";
                return false;
            }

            S.data[--S.top2] = e;  // 栈2 栈顶“指针”先减一，在入栈
            return true;
        }
        ```

7. **出栈**
   1. 栈1
      1. 传入 **栈名 &S** 、**返回值 &e**
      2. 先判断栈1是否为空
      3. 先读取栈顶元素，然后把栈顶指针减一
        ```
        bool Pop1(SharedStack &S, int &e) {
            // 先判断栈1是否为空
            if(Empty1(S)) {
                std::cout << "栈1为空";
                return false;
            }

            e = S.data[S.top1--];  // 读取栈顶元素值，再把栈1栈顶“指针”减一
            return true;
        }
        ```
    2. 栈2
       1. 传入 **栈名 &S** 、**返回值 &e**
       2. 先判断栈2是否为空
       3. 读取栈顶元素，再把栈顶指针加一
        ```
        bool Pop2(SharedStack &S, int &e) {
            // 先判断栈2是否为空
            if(Empty2(S)) {
                std::cout << "栈2为空";
                return false;
            }

            e = S.data[S.top2++];  // 读取栈2栈顶元素值，再把栈2栈顶“指针”加一
            return true;
        }
        ```

8. **读栈顶元素**
   1. 栈1
      1. 传入 **栈名 S** 、**返回值 &e**
      2. 先判断栈1是否为空
      3. 读取栈顶元素
        ```
        // 读栈顶元素
        bool GetTop1(SharedStack S, int &e) {
            // 先判断栈1是否为空
            if(Empty1(S)) {
                std::cout << "栈1为空";
                return false;
            }

            e = S.data[S.top1];  // 读取栈1的栈顶元素
            return true;
        }
        ```
    2. 栈2
       1. 传入 **栈名 S** 、**返回值 &e**
       2. 先判断栈2是否为空
       3. 读取栈2的栈顶元素
        ```
        bool GetTop2(SharedStack S, int &e) {
            // 先判断栈2是否为空
            if(Empty2(S)) {
                std::cout << "栈2为空";
                return false;
            }

            e = S.data[S.top2];  // 读取栈2的栈顶元素
            return true;
        }
        ```

9. **输出栈**
   1.  传入 **栈名 S**
   2.  先判断栈1是否为空，若不为空，则从栈顶开始遍历整个栈1，同时输出每个元素
   3.  再判断栈2是否为空，若不为空，则从栈顶开始遍历整个栈2，同时输出每个元素
    ```
    // 输出栈
    void PrintSharedStack(SharedStack S) {
        std::cout << "输出栈1: ";
        // 先判断栈 1 是否为空
        if(Empty1(S)) {
            std::cout << "栈1为空";
        }
        else {
            // 不为空，则从栈1的栈顶开始遍历整个栈1，同时输出元素
            for (int i = S.top1; i >= 0; i--) {
                std::cout << S.data[i] << " ";
            }
        }
        std::cout << std::endl;

        std::cout << "输出栈2: ";
        // 先判断栈2 是否为空
        if(Empty2(S)) {
            std::cout << "栈2为空";
        }
        else {
            // 不为空，则从栈2的栈顶开始遍历整个栈2，同时输出元素
            for (int i = S.top2; i < MAX_SIZE; i++) {
                std::cout << S.data[i] << " ";
            }
        }
        std::cout << std::endl;
    }
    ```

10. **求栈长**
    1.  栈1
        1.  传入 **栈名 S**
        2.  直接返回指针值加一
        ```
        int Length1(SharedStack S) {
            return S.top1 + 1;
        }        
        ```
    2. 栈2
       1. 传入 **栈名 S**
       2. 直接返回最大表长减栈顶指针值
        ```
        int Length2(SharedStack S) {
            return MAX_SIZE - S.top2;
        }
        ```

11. **销毁操作**
    1.  传入 **栈名 &S**
    2.  重置栈1的栈顶指针为 -1
    3.  重置栈2的栈顶指针为 MAX_SIZE
    ```
    // 销毁栈
    void DestroySharedStack(SharedStack &S) {
        S.top1 = -1;  // 重置栈1
        S.top2 = MAX_SIZE;  // 重置栈2
    }
    ```





# 链栈的实现
## 链栈（不带头结点）的实现
1. 首先定义不带头结点的链栈 **存储结构** 。包括 **数据域** 和 **指针域**
    ```
    // 不带头结点的链栈存储结构
    struct LSNode {
        int data;  // 数据域
        LSNode *next;  // 指针域
    };
    ```

2. **初始化**
   1. 传入 **头指针 \*&S**
   2. 把头指针指向空
    ```
    // 初始化链栈
    void InitStack(LSNode *&S) {
        S = nullptr;  // 不带头结点，就把头指针指向空
    }
    ```

3. **判空**
   1. 传入 **头指针 \*S**
   2. 直接返回头指针是否指向空，如果指向空，则链栈为空，如果不指向空，则链栈不为空
    ```
    // 判空操作
    bool Empty(LSNode *S) {
        return S == nullptr;  // 直接返回头指针是否为空
    }
    ```

4. **入栈**
   1. 传入 **头指针 \*&S** 、**要入栈的元素 e**
   2. 创建一个新结点 w
   3. 把 e 的值赋给新节点 w
   4. 把新结点 w 的 next 指针指向头指针指向的第一个结点
   5. 把头指针指向新结点
    ```
    // 入栈操作
    bool Push(LSNode *&S, int e) {
        LSNode *w = new LSNode;  // 创建一个新结点 w
        w -> data = e;  // 把 e 的值赋给新结点 w
        w -> next = S;  // 把新结点 w 的 next 指向头指针指向的当前第一个结点
        S = w;  // 把头指针指向 w

        return true;
    }
    ```

5. **出栈**
    1. 传入 **头指针 \*&S** 、**返回值 &e**
    2. 先判断栈是否为空
    3. 新建一个指针 p ，指向栈顶元素
    4. 用 e 返回栈顶元素的值
    5. 把栈顶指针指向第二元素
    6. 删除栈顶元素
    ```
    // 出栈操作
    bool Pop(LSNode *&S, int &e) {
        // 先判断栈是否为空
        if(Empty(S)) {
            std::cout << "栈为空" << std::endl;
            return false;
        }

        LSNode *p = S;  // 新建一个指针 p ，指向栈顶元素
        e = p -> data;  // 用 e 返回出栈元素的值
        S = S -> next;  // 把栈顶指针指向第二个元素
        delete p;  // 删除栈顶元素

        return true;
    }
    ```

6. **读栈顶元素**
   1. 传入 **头指针 \*S** 、**返回值 &e**
   2. 先判断栈是否为空
   3. 用 e 记录栈顶元素
    ```
    // 读栈顶元素
    bool GetTop(LSNode *S, int &e) {
        // 先判断栈是否为空
        if(Empty(S)) {
            std::cout << "栈为空" << std::endl;
            return false;
        }

        e = S -> data;  // e 记录栈顶元素
        return true;
    }
    ```

7. **输出栈**
   1. 传入 **头指针 \*S**
   2. 先判断栈是否为空
   3. 新建一个指针 p ，指向第一个元素
   4. 遍历整个栈，同时输出每个元素
    ```
    // 输出栈
    void PrintStack(LSNode *S) {
        // 先判断栈是否为空
        if(Empty(S)) {
            std::cout << "栈为空" << std::endl;
            return;
        }

        LSNode *p = S;  // 新建一个指针 p ，指向栈顶元素
        while(p) {
            std::cout << p -> data << " ";  // 打印当前结点的值
            p = p -> next;
        }
        std::cout << std::endl;
    }
    ```

8. **销毁栈**
   1. 传入 **头指针 \*&S**
   2. 设置一个返回值 e 
   3. 弹出所有元素，直到栈为空
    ```
    // 销毁栈
    void DestroyStack(LSNode *&S) {
        int e;
        // 循环弹出所有元素
        while(!Empty(S)) {
            Pop(S, e);
        }
    }
    ```




## 链栈（带头结点）的实现
1. 先定义链栈（带头结点）的 **存储结构** 。包括 **数据域** 和 **指针域**
    ```
    // 链栈（带头结点）存储结构
    struct LSNode {
        int data;  // 数据域
        LSNode *next;  // LSNode 类型的指针域，指向下一个结点
    };
    ```

2. **初始化**
   1. 传入 **头指针 \*&S**
   2. 创建一个头结点
   3. 把头结点的 next 指向空
    ```
    // 初始化链栈
    void InitStack(LSNode *&S) {
        S = new LSNode;  // 创建一个头结点
        S -> next = nullptr;  // 头结点的 next 设为空
    }
    ```

3. **判空**
   1. 传入 **头指针 \*S**
   2. 看头结点的指针是否指向空，如果指向空，则链表为空，若不指向空，则链表不为空
    ```
    // 判空
    bool Empty(LSNode *S) {
        return S -> next == nullptr;  // 看头结点的 next 是否为空
    }
    ```

4. **入栈**
   1. 传入 **头指针 \*&S** 、**要入栈的元素 e**
   2. 新建一个结点 w
   3. 把 e 的值赋给新结点 w
   4. 把新结点 w 的 next 指向当前的栈顶元素（不是头结点）
   5. 把头结点的 next 指向新结点 w
    ```
    // 入栈操作
    void Push(LSNode *&S, int e) {
        LSNode *w = new LSNode;  // 新建一个结点
        w -> data = e;  // 把 e 的值赋给 w
        w -> next = S -> next;  // 把新结点的 next 指向头结点的 next
        S -> next = w;  // 把头结点的 next 指向新结点 w
    }
    ```

5. **出栈**
   1. 传入 **头指针 \*&S** 、**返回值 &e**
   2. 先判断链栈是否为空
   3. 新建一个指针 p ，指向栈顶元素
   4. 用 e 返回栈顶元素的值
   5. 把头结点的 next 指向栈顶元素的后继结点
   6. 删除栈顶元素 p
    ```
    // 出栈操作
    bool Pop(LSNode *&S, int &e) {
        // 先判断栈是否为空
        if(Empty(S)) {
            std::cout << "栈为空" << std::endl;
            return false;
        }

        LSNode *p = S -> next;  // 新建一个指针 p ，指向第一个结点
        e = p -> data;  // 用 e 返回栈顶元素的值
        S -> next = p -> next;  // 把头结点的 next 指向栈顶元素的下一个元素
        delete p;  // 删除栈顶元素
        return true;
    }
    ```

6. **读栈顶元素**
   1. 传入 **头指针 \*S** 、**返回值 &e**
   2. 先判断链栈是否为空
   3. 用 e 返回栈顶元素的值
    ```
    // 读栈顶元素
    bool GetTop(LSNode *S, int &e) {
        // 先判断栈是否为空
        if(Empty(S)) {
            std::cout << "栈为空" << std::endl;
            return false;
        }

        e = S -> next -> data;  // 用 e 返回栈顶元素的值
        return true;
    }
    ```

7. **输出栈**
   1. 传入 **头指针 \*S**
   2. 先判断链栈是否为空
   3. 新建一个指针 p ，指向栈顶
   4. 遍历整个链栈，同时输出每个元素
    ```
    // 输出栈
    void PrintStack(LSNode *S) {
        // 先判断栈是否为空
        if(Empty(S)) {
            std::cout << "栈为空" << std::endl;
            return;
        }

        LSNode *p = S -> next;  // 新建一个指针 p ，指向栈顶元素
        while(p) {
            std::cout << p -> data << " ";  // 打印当前结点的数据域
            p = p -> next;
        }
        std::cout << std::endl;
    }
    ```

8. **销毁栈**
   1. 传入 **头指针 \*&S**
   2. 设置一个返回值 e
   3. 循环弹出所有元素，直到栈为空
    ```
    // 销毁栈
    void DestroyStack(LSNode *&S) {
        int e;
        // 循环弹出所有元素
        while(!Empty(S)) {
            Pop(S, e);
        }
    }
    ```





# 栈的应用
## 栈在括号匹配中的应用
用顺序栈实现括号匹配。


1. 先定义顺序栈的 **最大容量**
   ```
    #define MAX_SIZE 100  // 定义顺序栈的最大容量
   ```

2. 然后实现栈的 **基本操作**
   - **顺序栈结构体** 。包括用来存放括号的 **字符类型的数组** 和 **栈顶指针**
        ```
        // 顺序栈结构体
        struct SqStack {
            char data[MAX_SIZE];  // 静态数组存放栈中元素
            int top;  // 栈顶“指针”，指向栈顶元素的数组下标
        };
        ```
   - **初始化**
        ```
        // 初始化栈
        void InitStack(SqStack &S) {
            S.top = -1;  // 栈顶“指针”初始化为 -1，表示空栈
        }
        ```
   - **判空**
        ```
        // 判空
        bool Empty(SqStack S) {
            return S.top == -1;  // 直接返回栈顶“指针”是否为空
        }
        ```
   - **判满**
        ```
        // 判满
        bool Full(SqStack S) {
            return S.top == MAX_SIZE - 1;  // 直接返回栈顶指针是否为最大表长 - 1
        }
        ```
   - **入栈**
        ```
        // 入栈
        bool Push(SqStack &S, char e) {
            // 先判断栈是否已满
            if(Full(S)) {
                std::cout << "栈已满" << std::endl;
                return false;
            }

            S.data[++S.top] = e;  // 栈顶指针加一，然后入栈
            return true;
        }
        ```
   - **出栈**
        ```
        // 出栈
        bool Pop(SqStack &S, char &e) {
            // 先判断栈是否为空
            if(Empty(S)) {
                std::cout << "栈为空" << std::endl;
                return false;
            }

            e = S.data[S.top--];  // 读出栈顶元素的值，然后指针减一
            return true;
        }
        ```

3. 实现 **括号匹配算法**
   - 先声明一个栈 S
   - 初始化栈 S
   - 遍历每个字符，把左括号入栈，把右括号进行匹配
   - 如果是左括号，就先检查栈是否已满，若未满，则入栈
   - 如果是右括号，就先检查栈中是否还有左括号，若没有，则匹配失败，如果有就弹出栈顶的括号，检查是否匹配，不匹配则匹配失败
   - 当所有字符遍历完成后，返回栈中是否还有左括号，如果还有就说明匹配失败，如果没有就说明匹配成功
        ```
        // 括号匹配算法
        bool bracketCheck(char str[], int length) {
            SqStack S;  // 声明一个栈
            
            InitStack(S);  // 初始化栈

            // 遍历每个字符，把左括号入栈，如果是右括号就查看是否匹配
            for(int i=0; i < length; i++) {
                if(str[i] == '(' || str[i] == '[' || str[i] == '{') {
                    if(Full(S)) {
                        std::cout << "栈已满" << std::endl;
                        return false;
                    }
                    Push(S, str[i]);
                }
                else {
                    // 如果扫描到的是右括号，且当前栈为空，则匹配失败
                    if(Empty(S)) {
                        std::cout << "匹配失败";
                        return false;
                    }

                    char topChar;  // 栈顶元素
                    Pop(S, topChar);  // 弹出栈顶元素
                    // 进行括号匹配
                    if(str[i] == ')' && topChar != '(') {
                        std::cout << "匹配失败";
                        return false;
                    }
                    if(str[i] == ']' && topChar != '[') {
                        std::cout << "匹配失败";
                        return false;
                    }
                    if(str[i] == '}' && topChar != '{') {
                        std::cout << "匹配失败";
                        return false;
                    }
                }
            }

            return Empty(S);  // 检查栈是否为空，栈空说明匹配成功
        }
        ```

 


## 栈在表达式求值中的应用
- **算术表达式三要素** ：**运算符** 、**操作数** 、**界限符**
- **中缀表达式** ：运算符在两个操作数中间
- **后缀表达式** ：运算符在两个操作数后面
- **前缀表达式** ：运算符在两个操作数前面

- **中缀表达式转后缀表达式** 最好遵循 **“左优先”原则** ，即只要左边的运算符能先计算，就优先算左边的

- **后缀表达式求值** ：从左往右扫描，每遇到一个运算符，就让运算符前面最近的两个操作数执行相应运算，合体为一个操作数。

- **中缀表达式转前缀表达式** 最好遵循 **“右优先”原则** ，即只要右边的运算符能先计算，就优先算右边的

- **前缀表达式求值** ：从右往左扫描，每遇到一个运算符，就让运算符前面最近的两个操作数执行相应运算，合体为一个操作数


### 中缀表达式转后缀表达式的实现
1. 定义顺序栈的 **最大容量**
    ```
    #define MAX_SIZE 100  // 顺序栈的最大容量
    ```

2. 实现栈的 **基本操作**
   - 定义字符类型的 **顺序栈结构体** ，用于保存暂时还不能确定运算顺序的运算符。包括用来存储运算符的 **数组** ，**栈顶指针**
       ```
       // 顺序栈结构体（字符类型）
       // 用于保存暂时还不能确定运算顺序的运算符
       struct CharStack {
           char data[MAX_SIZE];  // 存储字符的数组
           int top;  // 栈顶指针
       };
       ```

    - **初始化**
        ```
        // 初始化栈
        void InitStack(CharStack &S) {
            S.top = -1;  // 把栈顶指针初始化为 -1 ，表示空栈
        }
        ```

    - **判空**
        ```
        // 判空
        bool Empty(CharStack S) {
            return S.top == -1;  // 看栈顶指针是否指向 -1
        }
        ```

    - **判满**
        ```
        // 判满
        bool Full(CharStack S) {
            return S.top == MAX_SIZE - 1;
        }
        ```

    - **入栈**
        ```
        // 入栈
        bool Push(CharStack &S, char e) {
            // 先判断栈是否已满
            if(Full(S)) {
                std::cout << "栈已满" << std::endl;
                return false;
            }

            S.data[++S.top] = e;  // 先把栈顶指针加一，在入栈
            return true;
        }
        ```

    - **出栈**
        ```
        // 出栈
        bool Pop(CharStack &S, char &e) {
            // 先判断栈是否为空
            if(Empty(S)) {
                std::cout << "栈为空" << std::endl;
                return false;
            }

            e = S.data[S.top--];  // 先出栈，然后把栈顶指针减一
            return true;
        }
        ```

    - **读栈顶元素**
        ```
        // 读栈顶元素
        bool GetTop(CharStack S, char &e) {
            // 先判断栈是否为空
            if(Empty(S)) {
                std::cout << "栈为空" << std::endl;
                return false;
            }

            e = S.data[S.top];  // 用 e 返回栈顶元素
            return true;
        }
        ```

3. **获取运算符优先级** ，用于运算符优先级比较。
    - 加号和减号的优先级为 1
    - 乘号和除号的优先级为 2
    - 其他运算符的优先级为 0
    ```
    // 获取运算符优先级
    int GetPriority(char op) {
        // 加号和减号的优先级为 1
        if(op == '+' || op == '-')
            return 1;
        
        // 乘号和除号优先级为 2
        if(op == '*' || op == '/')
            return 2;

        // 其他运算符优先级为 0
        return 0;
    }
    ```

4. **中缀表达式转后缀表达式算法**
   1. 传入 **中缀表达式**
   2. **声明** 并 **初始化** 一个 **顺序栈 S**，用于保存暂时不能确定运算顺序的运算符
   3. 再创建一个 **字符串 postfix** 用来存储转换后的 **后缀表达式**
   4. 从左到右处理中缀表达式中的各个元素，直到末尾
      1. 当遇到 **空格** 时，跳过空格
      2. 当遇到 **操作数** 时，提取整个数字（整数、小数、多位数），并加入后缀表达式，然后在数字后面加空格以便输出查看。最后退回一个字符，负责循环结束时，i 指向的是数字后面的第一个非数字字符
      3. 当遇到 **左括号** 时，把左括号入栈
      4. 当遇到 **右括号** 时，则依次弹出栈内运算符并加入后缀表达式，直到弹出左括号为止。
         - **注意** ：界限符不加入后缀表达式
      5. 当遇到 **运算符** 时，依次弹出栈中优先级高于或等于当前运算符的所有运算符，并加入后缀表达式。如果碰到左括号或栈空则停止。最后把当前运算符入栈。
   5. 遍历完中缀表达式中的所有字符后，将栈中剩余运算符依次弹出，并加入后缀表达式。
   6. 对得到的后缀表达式进行美化，即删除最后一个空格
    ```
    // 中缀表达式转后缀表达式
    std::string InfixToPostfix(const std::string &infix) {
        CharStack S;  // 声明一个栈
        InitStack(S);  // 初始化栈
        std::string postfix = "";  // 用来存储转换后的后缀表达式

        for(int i = 0; i < infix.length(); i++) {
            char c = infix[i];

            // 跳过空格
            if(c == ' ') 
                continue;

            // 处理操作数（包括多位数）
            if(std::isdigit(c)) {
                // 提取整个数字
                while(i < infix.length() && (std::isdigit(infix[i]) || infix[i] == '.')) {
                    postfix += infix[i++];  // 将当前字符添加到后缀表达式
                }
                postfix += ' ';  // 数字后面加空格分割
                i--;  // 回退一个字符，否则循环结束时，i 指向的是数字后的第一个非数字字符
                continue;
            }

            // 处理左括号
            if(c == '(') {
                Push(S, c);  // 把左括号入栈
                continue;
            }

            // 处理右括号
            if(c == ')') {
                char topChar;  // 用于返回栈顶元素

                // 遇到 ')' 则一次弹出栈内运算符并加入后缀表达式，直到弹出 '(' 为止
                while(GetTop(S, topChar) && topChar != '(') {
                    Pop(S, topChar);
                    postfix += topChar;
                    postfix += ' ';
                }
                Pop(S, topChar);  // 弹出左括号
                continue;
            }

            // 处理运算符
            char topChar;  // 用于返回栈顶元素

            // 依次弹出栈中优先级高于或等于当前运算符的所有运算符，并加入后缀表达式
            // 若碰到 '(' 或栈空则停止
            while(GetTop(S, topChar) && topChar != '(' && GetPriority(c) <= GetPriority(topChar)) {
                Pop(S, topChar);
                postfix += topChar;
                postfix += ' ';
            }
            Push(S, c);  // 最后把当前运算符入栈
        }

        // 弹出栈中剩余运算符
        char topChar;
        while(Pop(S, topChar)) {
            postfix += topChar;  // 把剩余运算符加入到后缀表达式中
            postfix += ' ';  // 每个运算符后加空格
        }

        // 删除最后一空格（如果有）
        if(!postfix.empty() && postfix.back() == ' ') {
            postfix.pop_back();
        }

        return postfix;  // 返回最终的后缀表达式
    }
    ```